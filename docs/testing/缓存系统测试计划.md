# ç¼“å­˜ç³»ç»Ÿæµ‹è¯•è®¡åˆ’

## ğŸ“‹ æµ‹è¯•è®¡åˆ’æ¦‚è¿°

**æµ‹è¯•ç›®æ ‡**: ç¡®ä¿ç»Ÿä¸€ç¼“å­˜ç³»ç»Ÿçš„åŠŸèƒ½æ­£ç¡®æ€§ã€æ€§èƒ½è¾¾æ ‡å’Œå¯é æ€§
**æµ‹è¯•èŒƒå›´**: ç»Ÿä¸€ç¼“å­˜æœåŠ¡çš„æ‰€æœ‰ç»„ä»¶å’ŒåŠŸèƒ½
**æµ‹è¯•å‘¨æœŸ**: 2å‘¨è®¾è®¡ + 3å‘¨æ‰§è¡Œ
**æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡**: 90%+
**æ€§èƒ½åŸºå‡†**: ç¼“å­˜å‘½ä¸­ç‡â‰¥85%ï¼Œå“åº”æ—¶é—´â‰¤140ms

---

## ğŸ¯ æµ‹è¯•ç­–ç•¥

### æµ‹è¯•é‡‘å­—å¡”
```
    E2E Tests (10%)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Integration     â”‚
  â”‚    Tests (30%)   â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Unit Tests (60%)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æµ‹è¯•åˆ†ç±»
1. **å•å…ƒæµ‹è¯•** - éªŒè¯å„ä¸ªç»„ä»¶çš„ç‹¬ç«‹åŠŸèƒ½
2. **é›†æˆæµ‹è¯•** - éªŒè¯ç»„ä»¶é—´çš„åä½œ
3. **æ€§èƒ½æµ‹è¯•** - éªŒè¯ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
4. **å‹åŠ›æµ‹è¯•** - éªŒè¯ç³»ç»Ÿåœ¨æé™æ¡ä»¶ä¸‹çš„è¡¨ç°
5. **å…¼å®¹æ€§æµ‹è¯•** - éªŒè¯ä¸ç°æœ‰ç³»ç»Ÿçš„å…¼å®¹æ€§

---

## ğŸ§ª å•å…ƒæµ‹è¯•è®¡åˆ’

### 1. æ ¸å¿ƒæ¥å£æµ‹è¯•

#### 1.1 IUnifiedCacheService æ¥å£æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/unified_cache_service_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
```dart
group('IUnifiedCacheService Tests', () {
  late MockUnifiedCacheService mockService;

  setUp(() {
    mockService = MockUnifiedCacheService();
  });

  test('should store and retrieve data correctly', () async {
    // Arrange
    const key = 'test_key';
    const data = 'test_data';

    // Act
    await mockService.put(key, data);
    final result = await mockService.get<String>(key);

    // Assert
    expect(result, equals(data));
  });

  test('should return null for non-existent key', () async {
    // Act
    final result = await mockService.get<String>('non_existent');

    // Assert
    expect(result, isNull);
  });

  test('should handle TTL expiration correctly', () async {
    // Arrange
    const key = 'ttl_test';
    const data = 'ttl_data';
    final config = CacheConfig(ttl: Duration(milliseconds: 100));

    // Act
    await mockService.put(key, data, config: config);
    await Future.delayed(Duration(milliseconds: 150));
    final result = await mockService.get<String>(key);

    // Assert
    expect(result, isNull);
  });
});
```

#### 1.2 CacheConfig é…ç½®æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/cache_config_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- é…ç½®åºåˆ—åŒ–/ååºåˆ—åŒ–
- é…ç½®éªŒè¯å’Œçº¦æŸæ£€æŸ¥
- é…ç½®å‰¯æœ¬å’Œä¿®æ”¹
- ç¯å¢ƒæ„ŸçŸ¥é…ç½®è°ƒæ•´

#### 1.3 CacheMetadata å…ƒæ•°æ®æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/cache_metadata_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- å…ƒæ•°æ®åˆ›å»ºå’Œæ›´æ–°
- è®¿é—®ç»Ÿè®¡è®°å½•
- åºåˆ—åŒ–/ååºåˆ—åŒ–
- æ ‡ç­¾ç®¡ç†

### 2. ç¼“å­˜ç­–ç•¥æµ‹è¯•

#### 2.1 LRU ç­–ç•¥æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/strategies/lru_strategy_test.dart`

```dart
group('LRU Strategy Tests', () {
  late LRUCacheStrategy strategy;

  setUp(() {
    strategy = LRUCacheStrategy();
  });

  test('should prioritize recently accessed items', () {
    // Arrange
    final metadata1 = CacheMetadata.create(size: 100);
    final metadata2 = CacheMetadata.create(size: 100);
    final lastAccess1 = DateTime.now().subtract(Duration(minutes: 10));
    final lastAccess2 = DateTime.now().subtract(Duration(minutes: 1));

    // Act
    final priority1 = strategy.calculatePriority('key1', null, metadata1, 5, lastAccess1);
    final priority2 = strategy.calculatePriority('key2', null, metadata2, 5, lastAccess2);

    // Assert
    expect(priority2, greaterThan(priority1));
  });

  test('should calculate correct expiry time', () {
    // Arrange
    final config = CacheConfig(ttl: Duration(hours: 2));
    final before = DateTime.now();

    // Act
    final expiry = strategy.calculateExpiry('test', 'data', config);

    // Assert
    final diff = expiry.difference(before);
    expect(diff.inHours, equals(2));
  });
});
```

#### 2.2 Adaptive ç­–ç•¥æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/strategies/adaptive_strategy_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- è®¿é—®æ¨¡å¼åˆ†æ
- åŠ¨æ€TTLè°ƒæ•´
- ä¼˜å…ˆçº§è®¡ç®—
- ç­–ç•¥é€‚åº”æ€§éªŒè¯

#### 2.3 æ··åˆç­–ç•¥æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/strategies/hybrid_strategy_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- å¤šç­–ç•¥åŠ æƒè®¡ç®—
- æ·˜æ±°å†³ç­–é€»è¾‘
- æ€§èƒ½å¹³è¡¡éªŒè¯

### 3. é…ç½®ç®¡ç†æµ‹è¯•

#### 3.1 CacheConfigManager æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/config/cache_config_manager_test.dart`

```dart
group('CacheConfigManager Tests', () {
  late CacheConfigManager manager;

  setUp(() {
    manager = CacheConfigManager(environment: CacheEnvironment.testing);
  });

  test('should return correct predefined config', () {
    // Act
    final config = manager.getConfig('search_results');

    // Assert
    expect(config.ttl, equals(Duration(minutes: 15)));
    expect(config.priority, equals(6));
    expect(config.tags, contains('search'));
  });

  test('should adjust config for environment', () {
    // Act
    final config = manager.getConfig('search_results');

    // Assert
    expect(config.persistent, isFalse); // æµ‹è¯•ç¯å¢ƒä¸æŒä¹…åŒ–
    expect(config.ttl!.inSeconds, equals(30)); // æµ‹è¯•ç¯å¢ƒçŸ­TTL
  });

  test('should validate custom config', () {
    // Act & Assert
    expect(() => manager.createCustomConfig(priority: 15), throwsA(isA<CacheConfigValidationException>()));
  });
});
```

### 4. æ™ºèƒ½åŠŸèƒ½æµ‹è¯•

#### 4.1 IntelligentCacheManager æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/intelligent/intelligent_cache_manager_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- æ™ºèƒ½é…ç½®é€‰æ‹©
- è®¿é—®æ¨¡å¼å­¦ä¹ 
- æ€§èƒ½ç›‘æ§è®°å½•
- è‡ªåŠ¨ä¼˜åŒ–è§¦å‘

#### 4.2 æ€§èƒ½ç›‘æ§å™¨æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/unit/cache/intelligent/performance_monitor_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- è®¿é—®ç»Ÿè®¡è®°å½•
- æ€§èƒ½æŒ‡æ ‡è®¡ç®—
- é”™è¯¯ç»Ÿè®¡è·Ÿè¸ª
- æ•°æ®ç»´æŠ¤é€»è¾‘

---

## ğŸ”— é›†æˆæµ‹è¯•è®¡åˆ’

### 1. ç¼“å­˜æœåŠ¡é›†æˆæµ‹è¯•

#### 1.1 ç«¯åˆ°ç«¯ç¼“å­˜æµç¨‹æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/integration/cache/end_to_end_cache_test.dart`

```dart
group('End-to-End Cache Tests', () {
  late IUnifiedCacheService cacheService;

  setUp(() async {
    cacheService = await createTestCacheService();
  });

  tearDown(() async {
    await cacheService.clear();
  });

  test('should handle complete cache lifecycle', () async {
    // Arrange
    const key = 'lifecycle_test';
    final data = generateTestData();

    // Act & Assert - Store
    await cacheService.put(key, data);
    expect(await cacheService.exists(key), isTrue);

    // Act & Assert - Retrieve
    final retrieved = await cacheService.get<TestData>(key);
    expect(retrieved, isNotNull);
    expect(retrieved!.id, equals(data.id));

    // Act & Assert - Update
    final updatedData = TestData(id: data.id, name: 'updated');
    await cacheService.put(key, updatedData);
    final retrievedUpdated = await cacheService.get<TestData>(key);
    expect(retrievedUpdated!.name, equals('updated'));

    // Act & Assert - Delete
    await cacheService.remove(key);
    expect(await cacheService.exists(key), isFalse);
  });
});
```

#### 1.2 æ‰¹é‡æ“ä½œæµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/integration/cache/batch_operations_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- æ‰¹é‡å­˜å‚¨å’Œæ£€ç´¢
- æ‰¹é‡åˆ é™¤æ€§èƒ½
- å¹¶å‘æ‰¹é‡æ“ä½œ
- äº‹åŠ¡ä¸€è‡´æ€§

#### 1.3 ç­–ç•¥åˆ‡æ¢æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/integration/cache/strategy_switching_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- è¿è¡Œæ—¶ç­–ç•¥åˆ‡æ¢
- æ•°æ®è¿ç§»éªŒè¯
- æ€§èƒ½å½±å“è¯„ä¼°

### 2. å…¼å®¹æ€§é›†æˆæµ‹è¯•

#### 2.1 ç°æœ‰æœåŠ¡å…¼å®¹æ€§æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/integration/compatibility/existing_services_test.dart`

```dart
group('Existing Services Compatibility', () {
  late SearchCacheService legacySearchService;
  late FilterCacheService legacyFilterService;
  late IUnifiedCacheService unifiedService;

  setUp(() async {
    legacySearchService = SearchCacheService();
    await legacySearchService.initialize();

    legacyFilterService = FilterCacheService();

    unifiedService = await createUnifiedServiceWithAdapters();
  });

  test('should be compatible with SearchCacheService data', () async {
    // Arrange - ä½¿ç”¨ç°æœ‰æœåŠ¡å­˜å‚¨æ•°æ®
    final criteria = FundSearchCriteria(query: 'test');
    final results = generateFundResults();
    await legacySearchService.cacheSearchResults(criteria, results);

    // Act - ä½¿ç”¨ç»Ÿä¸€æœåŠ¡æ£€ç´¢
    final cacheKey = criteria.cacheKey;
    final retrievedResults = await unifiedService.get<List<Fund>>(cacheKey);

    // Assert
    expect(retrievedResults, isNotNull);
    expect(retrievedResults!.length, equals(results.length));
  });
});
```

#### 2.2 æ•°æ®æ ¼å¼å…¼å®¹æ€§æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/integration/compatibility/data_format_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- æ—§æ ¼å¼æ•°æ®è¯»å–
- æ–°æ—§æ ¼å¼è½¬æ¢
- ç‰ˆæœ¬å‡çº§å…¼å®¹æ€§

---

## âš¡ æ€§èƒ½æµ‹è¯•è®¡åˆ’

### 1. åŸºå‡†æ€§èƒ½æµ‹è¯•

#### 1.1 ç¼“å­˜æ“ä½œæ€§èƒ½æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/performance/cache_operations_benchmark.dart`

```dart
group('Cache Operations Performance', () {
  late IUnifiedCacheService cacheService;

  setUp(() async {
    cacheService = await createProductionCacheService();
  });

  test('should meet put operation performance target', () async {
    // Arrange
    const iterations = 1000;
    final testData = generateLargeTestData(1024); // 1KBæ•°æ®

    // Act
    final stopwatch = Stopwatch()..start();
    for (int i = 0; i < iterations; i++) {
      await cacheService.put('perf_test_$i', testData);
    }
    stopwatch.stop();

    // Assert
    final avgTime = stopwatch.elapsedMilliseconds / iterations;
    expect(avgTime, lessThan(5.0)); // å¹³å‡5msä»¥å†…
  });

  test('should meet get operation performance target', () async {
    // Arrange
    const iterations = 1000;
    for (int i = 0; i < iterations; i++) {
      await cacheService.put('perf_test_$i', 'data_$i');
    }

    // Act
    final stopwatch = Stopwatch()..start();
    int hits = 0;
    for (int i = 0; i < iterations; i++) {
      final result = await cacheService.get<String>('perf_test_$i');
      if (result != null) hits++;
    }
    stopwatch.stop();

    // Assert
    final avgTime = stopwatch.elapsedMilliseconds / iterations;
    expect(avgTime, lessThan(1.0)); // å¹³å‡1msä»¥å†…
    expect(hits / iterations, greaterThan(0.95)); // å‘½ä¸­ç‡>95%
  });
});
```

#### 1.2 å†…å­˜ä½¿ç”¨æ€§èƒ½æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/performance/memory_usage_test.dart`

**æµ‹è¯•ç”¨ä¾‹**:
- å†…å­˜ä½¿ç”¨é‡ç›‘æ§
- åƒåœ¾å›æ”¶é¢‘ç‡
- å†…å­˜æ³„æ¼æ£€æµ‹
- å†…å­˜å‹åŠ›å“åº”

#### 1.3 å¹¶å‘æ€§èƒ½æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/performance/concurrency_test.dart`

```dart
test('should handle concurrent operations efficiently', () async {
  // Arrange
  const concurrentOperations = 100;
  const operationsPerThread = 50;

  // Act
  final futures = <Future>[];
  for (int i = 0; i < concurrentOperations; i++) {
    futures.add(_performConcurrentOperations(i, operationsPerThread));
  }

  final stopwatch = Stopwatch()..start();
  await Future.wait(futures);
  stopwatch.stop();

  // Assert
  expect(stopwatch.elapsedMilliseconds, lessThan(5000)); // 5ç§’å†…å®Œæˆ
});

Future<void> _performConcurrentOperations(int threadId, int count) async {
  for (int i = 0; i < count; i++) {
    final key = 'thread_${threadId}_item_$i';
    await cacheService.put(key, 'data');
    await cacheService.get<String>(key);
  }
}
```

### 2. å‹åŠ›æµ‹è¯•

#### 2.1 é«˜è´Ÿè½½å‹åŠ›æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/stress/high_load_test.dart`

**æµ‹è¯•ç›®æ ‡**:
- æ”¯æŒ10,000 QPSçš„ç¼“å­˜æ“ä½œ
- å†…å­˜ä½¿ç”¨ä¸è¶…è¿‡150MB
- å“åº”æ—¶é—´P99 < 100ms
- ç³»ç»Ÿç¨³å®šæ€§æŒç»­1å°æ—¶

```dart
test('should sustain high load for extended period', () async {
  // Arrange
  const duration = Duration(hours: 1);
  const targetQPS = 10000;
  final stopWatch = Stopwatch()..start();
  int operationsCompleted = 0;

  // Act
  final testFuture = _generateLoad(targetQPS);

  while (stopWatch.elapsed < duration) {
    await Future.delayed(Duration(seconds: 10));

    // Monitor metrics
    final stats = await cacheService.getStatistics();
    final accessStats = cacheService.getAccessStats();

    // Assert checkpoints
    expect(stats.totalSize, lessThan(150 * 1024 * 1024)); // < 150MB
    expect(accessStats.averageResponseTimeMs, lessThan(100)); // < 100ms
    expect(accessStats.hitRate, greaterThan(0.8)); // > 80% hit rate
  }

  await testFuture;
});
```

#### 2.2 å†…å­˜å‹åŠ›æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/stress/memory_pressure_test.dart`

**æµ‹è¯•åœºæ™¯**:
- é€æ­¥å¢åŠ ç¼“å­˜æ•°æ®é‡
- ç›‘æ§å†…å­˜ä½¿ç”¨å’Œæ¸…ç†è¡Œä¸º
- éªŒè¯å†…å­˜é™åˆ¶æ‰§è¡Œ
- æµ‹è¯•å†…å­˜å‹åŠ›ä¸‹çš„æ€§èƒ½

#### 2.3 ç½‘ç»œå¼‚å¸¸æµ‹è¯•
**æµ‹è¯•æ–‡ä»¶**: `test/stress/network_resilience_test.dart`

**æµ‹è¯•åœºæ™¯**:
- ç½‘ç»œå»¶è¿Ÿå’Œä¸¢åŒ…æ¨¡æ‹Ÿ
- è¿æ¥ä¸­æ–­æ¢å¤æµ‹è¯•
- é™çº§ç­–ç•¥éªŒè¯
- æ•°æ®ä¸€è‡´æ€§ä¿è¯

---

## ğŸ”§ æµ‹è¯•å·¥å…·å’Œè¾…åŠ©è®¾æ–½

### 1. æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨

#### 1.1 ç¼“å­˜æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
**æ–‡ä»¶**: `test/utils/cache_data_generator.dart`

```dart
class CacheDataGenerator {
  static FundSearchCriteria generateSearchCriteria({
    String? query,
    List<String>? fundTypes,
    double? minSize,
  }) {
    return FundSearchCriteria(
      query: query ?? 'åŸºé‡‘${Random().nextInt(1000)}',
      fundTypes: fundTypes ?? ['è‚¡ç¥¨å‹', 'å€ºåˆ¸å‹', 'æ··åˆå‹'],
      minSize: minSize ?? Random().nextDouble() * 100000000,
    );
  }

  static List<Fund> generateFundResults({int count = 10}) {
    return List.generate(count, (index) => Fund(
      code: '${Random().nextInt(900000) + 100000}',
      name: 'æµ‹è¯•åŸºé‡‘${index + 1}',
      company: 'æµ‹è¯•å…¬å¸${index + 1}',
      type: ['è‚¡ç¥¨å‹', 'å€ºåˆ¸å‹', 'æ··åˆå‹'][Random().nextInt(3)],
      size: Random().nextDouble() * 100000000,
    ));
  }

  static Map<String, dynamic> generateLargeData(int sizeKB) {
    final targetSize = sizeKB * 1024;
    final data = <String, dynamic>{};
    int currentSize = 0;

    int index = 0;
    while (currentSize < targetSize) {
      final value = 'x' * math.min(1024, targetSize - currentSize);
      data['field_$index'] = value;
      currentSize += value.length + 10; // +10 for field name and overhead
      index++;
    }

    return data;
  }
}
```

#### 1.2 æ€§èƒ½æµ‹è¯•è¾…åŠ©å·¥å…·
**æ–‡ä»¶**: `test/utils/performance_test_helper.dart`

```dart
class PerformanceTestHelper {
  static Future<TestResult> runTimedTest(
    String name,
    Future<void> Function() testFunction,
  ) async {
    final stopwatch = Stopwatch()..start();

    try {
      await testFunction();
      stopwatch.stop();

      return TestResult(
        name: name,
        success: true,
        duration: stopwatch.elapsed,
      );
    } catch (e) {
      stopwatch.stop();

      return TestResult(
        name: name,
        success: false,
        duration: stopwatch.elapsed,
        error: e.toString(),
      );
    }
  }

  static Future<List<TestResult>> runLoadTest(
    String name,
    Future<void> Function() operation,
    int durationSeconds,
  ) async {
    final results = <TestResult>[];
    final stopwatch = Stopwatch()..start();
    int operationCount = 0;

    while (stopwatch.elapsed.inSeconds < durationSeconds) {
      final result = await runTimedTest(
        '${name}_operation_${++operationCount}',
        operation,
      );
      results.add(result);

      // çŸ­æš‚ä¼‘æ¯ä»¥é¿å…è¿‡åº¦CPUå ç”¨
      await Future.delayed(Duration(milliseconds: 1));
    }

    return results;
  }
}

class TestResult {
  final String name;
  final bool success;
  final Duration duration;
  final String? error;

  const TestResult({
    required this.name,
    required this.success,
    required this.duration,
    this.error,
  });
}
```

### 2. Mock å¯¹è±¡

#### 2.1 ç¼“å­˜æœåŠ¡ Mock
**æ–‡ä»¶**: `test/mocks/mock_cache_service.dart`

```dart
class MockUnifiedCacheService extends Mock implements IUnifiedCacheService {
  final Map<String, dynamic> _storage = {};
  final Map<String, DateTime> _expiry = {};
  final Map<String, CacheConfig> _configs = {};

  @override
  Future<T?> get<T>(String key, {Type? type}) async {
    if (!_storage.containsKey(key)) return null;

    if (_expiry.containsKey(key) && DateTime.now().isAfter(_expiry[key]!)) {
      _storage.remove(key);
      _expiry.remove(key);
      _configs.remove(key);
      return null;
    }

    return _storage[key] as T?;
  }

  @override
  Future<void> put<T>(String key, T data, {CacheConfig? config}) async {
    _storage[key] = data;
    if (config?.ttl != null) {
      _expiry[key] = DateTime.now().add(config!.ttl!);
    }
    if (config != null) {
      _configs[key] = config;
    }
  }

  @override
  Future<bool> exists(String key) async {
    return _storage.containsKey(key) &&
           (!_expiry.containsKey(key) || DateTime.now().isBefore(_expiry[key]!));
  }

  @override
  Future<bool> remove(String key) async {
    _storage.remove(key);
    _expiry.remove(key);
    _configs.remove(key);
    return true;
  }

  @override
  Future<void> clear() async {
    _storage.clear();
    _expiry.clear();
    _configs.clear();
  }

  // å…¶ä»–æ–¹æ³•çš„ Mock å®ç°...
}
```

### 3. æµ‹è¯•ç¯å¢ƒé…ç½®

#### 3.1 æµ‹è¯•ç¼“å­˜æœåŠ¡å·¥å‚
**æ–‡ä»¶**: `test/helpers/test_cache_service_factory.dart`

```dart
class TestCacheServiceFactory {
  static Future<IUnifiedCacheService> createUnitTestCacheService() async {
    final storage = InMemoryCacheStorage();
    final strategy = LRUCacheStrategy();
    final configManager = CacheConfigManager(environment: CacheEnvironment.testing);

    return UnifiedCacheService(
      storage: storage,
      strategy: strategy,
      configManager: configManager,
    );
  }

  static Future<IUnifiedCacheService> createIntegrationTestCacheService() async {
    final storage = HiveCacheStorage(testMode: true);
    await storage.initialize();

    final strategy = AdaptiveCacheStrategy();
    final configManager = CacheConfigManager(environment: CacheEnvironment.staging);

    return IntelligentCacheManager(
      UnifiedCacheService(
        storage: storage,
        strategy: strategy,
        configManager: configManager,
      ),
      configManager,
    );
  }

  static Future<IUnifiedCacheService> createPerformanceTestCacheService() async {
    final storage = HighPerformanceCacheStorage();
    await storage.initialize();

    final strategy = HybridCacheStrategy();
    final configManager = CacheConfigManager(environment: CacheEnvironment.production);

    return IntelligentCacheManager(
      UnifiedCacheService(
        storage: storage,
        strategy: strategy,
        configManager: configManager,
      ),
      configManager,
    );
  }
}
```

---

## ğŸ“Š æµ‹è¯•æ‰§è¡Œè®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€åŠŸèƒ½éªŒè¯ (ç¬¬1å‘¨)
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•æ‰§è¡Œå’Œé€šè¿‡
- [ ] æ ¸å¿ƒæ¥å£åŠŸèƒ½éªŒè¯
- [ ] åŸºæœ¬æ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] æµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆ

### é˜¶æ®µ2ï¼šé›†æˆæµ‹è¯• (ç¬¬2å‘¨)
- [ ] ç»„ä»¶é›†æˆæµ‹è¯•
- [ ] å…¼å®¹æ€§æµ‹è¯•
- [ ] æ•°æ®è¿ç§»æµ‹è¯•
- [ ] é”™è¯¯å¤„ç†æµ‹è¯•

### é˜¶æ®µ3ï¼šæ€§èƒ½å’Œå‹åŠ›æµ‹è¯• (ç¬¬3å‘¨)
- [ ] æ€§èƒ½åŸºå‡†éªŒè¯
- [ ] å‹åŠ›æµ‹è¯•æ‰§è¡Œ
- [ ] å†…å­˜ä½¿ç”¨åˆ†æ
- [ ] å¹¶å‘æ€§èƒ½æµ‹è¯•

### æ¯æ—¥æ‰§è¡Œè®¡åˆ’
```
09:00-10:00  å•å…ƒæµ‹è¯•æ‰§è¡Œ
10:00-12:00  é›†æˆæµ‹è¯•æ‰§è¡Œ
14:00-16:00  æ€§èƒ½æµ‹è¯•æ‰§è¡Œ
16:00-17:00  æµ‹è¯•ç»“æœåˆ†æ
```

---

## ğŸ“ˆ æµ‹è¯•æˆåŠŸæ ‡å‡†

### åŠŸèƒ½æ€§æ ‡å‡†
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡ç‡: 100%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡ç‡: 95%+
- [ ] å…¼å®¹æ€§æµ‹è¯•é€šè¿‡ç‡: 100%
- [ ] æµ‹è¯•è¦†ç›–ç‡: 90%+

### æ€§èƒ½æ ‡å‡†
- [ ] ç¼“å­˜å‘½ä¸­ç‡: â‰¥85%
- [ ] å¹³å‡å“åº”æ—¶é—´: â‰¤140ms
- [ ] P99å“åº”æ—¶é—´: â‰¤500ms
- [ ] å†…å­˜ä½¿ç”¨: â‰¤150MB
- [ ] å¹¶å‘æ”¯æŒ: â‰¥10,000 QPS

### å¯é æ€§æ ‡å‡†
- [ ] è¿ç»­è¿è¡Œç¨³å®šæ€§: â‰¥24å°æ—¶
- [ ] å†…å­˜æ³„æ¼: 0
- [ ] æ•°æ®ä¸€è‡´æ€§: 100%
- [ ] é”™è¯¯æ¢å¤: è‡ªåŠ¨

### å…¼å®¹æ€§æ ‡å‡†
- [ ] ç°æœ‰åŠŸèƒ½å…¼å®¹æ€§: 100%
- [ ] æ•°æ®æ ¼å¼å…¼å®¹æ€§: 100%
- [ ] APIæ¥å£å…¼å®¹æ€§: 100%
- [ ] å¹³å°å…¼å®¹æ€§: 100%

---

## ğŸš¨ é£é™©å’Œç¼“è§£æªæ–½

### æµ‹è¯•é£é™©
1. **æµ‹è¯•ç¯å¢ƒä¸ç¨³å®š**
   - ç¼“è§£ï¼šä½¿ç”¨å®¹å™¨åŒ–æµ‹è¯•ç¯å¢ƒ
   - å¤‡ç”¨ï¼šæœ¬åœ°æµ‹è¯•ç¯å¢ƒ

2. **æ€§èƒ½æµ‹è¯•ç»“æœä¸ç¨³å®š**
   - ç¼“è§£ï¼šå¤šæ¬¡è¿è¡Œå–å¹³å‡å€¼
   - å¤‡ç”¨ï¼šä½¿ç”¨æ€§èƒ½åŸºå‡†å¯¹æ¯”

3. **å…¼å®¹æ€§æµ‹è¯•è¦†ç›–ä¸å…¨**
   - ç¼“è§£ï¼šè¯¦ç»†çš„å…¼å®¹æ€§æ£€æŸ¥æ¸…å•
   - å¤‡ç”¨ï¼šæ‰‹åŠ¨è¡¥å……æµ‹è¯•

### ç¼“è§£æªæ–½
1. **è‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿**
   - CI/CDé›†æˆè‡ªåŠ¨æµ‹è¯•
   - æµ‹è¯•å¤±è´¥è‡ªåŠ¨é€šçŸ¥
   - æµ‹è¯•æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ

2. **æµ‹è¯•æ•°æ®ç®¡ç†**
   - æ ‡å‡†åŒ–æµ‹è¯•æ•°æ®é›†
   - æµ‹è¯•æ•°æ®ç‰ˆæœ¬æ§åˆ¶
   - æµ‹è¯•ç¯å¢ƒéš”ç¦»

3. **ç›‘æ§å’Œå‘Šè­¦**
   - æµ‹è¯•æ‰§è¡ŒçŠ¶æ€ç›‘æ§
   - æ€§èƒ½æŒ‡æ ‡å®æ—¶ç›‘æ§
   - å¼‚å¸¸æƒ…å†µè‡ªåŠ¨å‘Šè­¦

---

## ğŸ“ æµ‹è¯•æ–‡æ¡£å’ŒæŠ¥å‘Š

### æµ‹è¯•æ–‡æ¡£
1. **æµ‹è¯•è®¡åˆ’æ–‡æ¡£** - æœ¬æ–‡æ¡£
2. **æµ‹è¯•ç”¨ä¾‹æ–‡æ¡£** - è¯¦ç»†æµ‹è¯•ç”¨ä¾‹è¯´æ˜
3. **æµ‹è¯•ç¯å¢ƒæ–‡æ¡£** - ç¯å¢ƒé…ç½®å’Œéƒ¨ç½²è¯´æ˜
4. **æµ‹è¯•æ‰§è¡Œæ‰‹å†Œ** - æµ‹è¯•æ‰§è¡Œæ­¥éª¤æŒ‡å—

### æµ‹è¯•æŠ¥å‘Š
1. **æ¯æ—¥æµ‹è¯•æŠ¥å‘Š** - å½“æ—¥æµ‹è¯•æ‰§è¡Œæƒ…å†µ
2. **é˜¶æ®µæ€§æµ‹è¯•æŠ¥å‘Š** - æ¯å‘¨æµ‹è¯•æ€»ç»“
3. **æœ€ç»ˆæµ‹è¯•æŠ¥å‘Š** - å®Œæ•´æµ‹è¯•ç»“æœåˆ†æ
4. **æ€§èƒ½æµ‹è¯•æŠ¥å‘Š** - æ€§èƒ½æŒ‡æ ‡è¯¦ç»†åˆ†æ

### è´¨é‡ä¿è¯
- [ ] æµ‹è¯•ç”¨ä¾‹è¯„å®¡
- [ ] æµ‹è¯•ä»£ç å®¡æŸ¥
- [ ] æµ‹è¯•ç»“æœéªŒè¯
- [ ] ç¼ºé™·è·Ÿè¸ªç®¡ç†

---

*æœ¬æµ‹è¯•è®¡åˆ’å°†æ ¹æ®å®é™…æ‰§è¡Œæƒ…å†µå’Œå‘ç°çš„é—®é¢˜è¿›è¡ŒæŒç»­æ›´æ–°å’Œä¼˜åŒ–*