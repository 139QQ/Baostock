# å…¼å®¹æ€§ä¿è¯ç­–ç•¥ - Baostock æ£•åœ°å¼€å‘å…¼å®¹æ€§ç®¡ç†

## ğŸ¯ ç­–ç•¥æ¦‚è¿°

**ç­–ç•¥ç›®æ ‡**: ç¡®ä¿æ£•åœ°å¼€å‘è¿‡ç¨‹ä¸­çš„å‘åå…¼å®¹æ€§ï¼Œä¿æŠ¤ç°æœ‰åŠŸèƒ½å’Œç”¨æˆ·æ•°æ®
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰å››ä¸ªå¼€å‘é˜¶æ®µçš„å…¼å®¹æ€§ç®¡ç†
**ç­–ç•¥ç‰ˆæœ¬**: v1.0
**åˆ¶å®šæ—¥æœŸ**: 2025-10-30

---

## ğŸ”„ å…¼å®¹æ€§åŸåˆ™

### æ ¸å¿ƒåŸåˆ™
1. **ä¸ç ´ååŸåˆ™**: æ–°ä»£ç ä¸èƒ½ç ´åç°æœ‰åŠŸèƒ½
2. **æ¸è¿›è¿ç§»**: é€æ­¥æ›¿æ¢æ—§å®ç°ï¼Œé¿å…å¤§çˆ†ç‚¸å¼å˜æ›´
3. **å‘åå…¼å®¹**: ä¿æŒç°æœ‰ API æ¥å£ä¸å˜
4. **æ•°æ®å®‰å…¨**: ç¡®ä¿ç”¨æˆ·æ•°æ®å®Œæ•´æ€§å’Œä¸€è‡´æ€§
5. **ç”¨æˆ·ä½“éªŒ**: æ”¹è¿›è¿‡ç¨‹ä¸­ä¿æŒç”¨æˆ·ä½“éªŒè¿ç»­æ€§

### å®æ–½åŸåˆ™
- **æ¥å£éš”ç¦»**: æ–°æ—§ç³»ç»Ÿé€šè¿‡é€‚é…å™¨éš”ç¦»
- **ç‰ˆæœ¬æ§åˆ¶**: æ˜ç¡®çš„ç‰ˆæœ¬ç®¡ç†å’Œå…¼å®¹æ€§æ ‡è¯†
- **æµ‹è¯•è¦†ç›–**: å…¨é¢çš„å…¼å®¹æ€§æµ‹è¯•è¦†ç›–
- **å›æ»šæœºåˆ¶**: å¿«é€Ÿå›æ»šåˆ°ç¨³å®šç‰ˆæœ¬çš„èƒ½åŠ›

---

## ğŸ—ï¸ API å…¼å®¹æ€§ä¿è¯

### 1. æ¥å£å…¼å®¹æ€§ç­–ç•¥

#### å…¬å…±æ¥å£ä¿æŠ¤
```dart
// ğŸ”’ ä¿æŒä¸å˜çš„å…¬å…±æ¥å£
abstract class IFundService {
  // ç°æœ‰æ¥å£ä¿æŒå®Œå…¨å…¼å®¹
  Future<List<FundData>> getFundList(String query);
  Stream<FundData> getRealTimeData(String code);
}

// ğŸ†• æ–°æ¥å£ä½¿ç”¨å‘½åå‚æ•°æˆ–å¯é€‰å‚æ•°
abstract class IFundServiceV2 extends IFundService {
  // æ‰©å±•æ¥å£ï¼Œå‘åå…¼å®¹
  Future<List<FundData>> getFundList(String query, {
    FilterCriteria? criteria,  // å¯é€‰å‚æ•°
    bool useCache = true,       // é»˜è®¤å€¼ä¿æŒæ—§è¡Œä¸º
  });
}
```

#### é€‚é…å™¨æ¨¡å¼å®ç°
```dart
// ğŸ”„ æ–°æ—§ç³»ç»Ÿé€‚é…å™¨
class FundServiceAdapter implements IFundService {
  final IFundServiceV2 _newService;

  FundServiceAdapter(this._newService);

  @override
  Future<List<FundData>> getFundList(String query) {
    // å°†æ—§è°ƒç”¨è½¬æ¢ä¸ºæ–°è°ƒç”¨
    return _newService.getFundList(query, useCache: true);
  }

  @override
  Stream<FundData> getRealTimeData(String code) {
    return _newService.getRealTimeData(code);
  }
}
```

#### å¼ƒç”¨ç®¡ç†ç­–ç•¥
```dart
// âš ï¸ å¼ƒç”¨æ ‡è¯†å’Œè¿ç§»æŒ‡å—
@Deprecated('ä½¿ç”¨ getFundListV2 æ›¿ä»£ï¼Œå°†åœ¨ v2.0 ä¸­ç§»é™¤')
Future<List<FundData>> getFundListLegacy(String query) {
  // å®ç°å…¼å®¹æ€§é€»è¾‘
  return getFundListV2(query, useLegacyFormat: true);
}

// ğŸ“ è¿ç§»æŒ‡å—æ³¨é‡Š
/// è¿ç§»æŒ‡å—:
/// æ—§æ–¹å¼: getFundListLegacy(query)
/// æ–°æ–¹å¼: getFundListV2(query, criteria: FilterCriteria.default())
/// è¿ç§»æ—¶é—´: å»ºè®®åœ¨ 2026-01-31 å‰å®Œæˆ
```

### 2. æ•°æ®æ ¼å¼å…¼å®¹æ€§

#### æ•°æ®æ¨¡å‹ç‰ˆæœ¬æ§åˆ¶
```dart
// ğŸ“Š æ•°æ®æ¨¡å‹ç‰ˆæœ¬ç®¡ç†
class FundData {
  final String code;
  final String name;
  final double price;

  // ç‰ˆæœ¬æ§åˆ¶å­—æ®µ
  final int schemaVersion;
  final Map<String, dynamic>? legacyFields;

  FundData({
    required this.code,
    required this.name,
    required this.price,
    this.schemaVersion = 2,
    this.legacyFields,
  });

  // ğŸ”§ å…¼å®¹æ€§æ„é€ å‡½æ•°
  factory FundData.fromLegacyJson(Map<String, dynamic> json) {
    return FundData(
      code: json['fund_code'] ?? json['code'],  // å…¼å®¹æ—§å­—æ®µå
      name: json['fund_name'] ?? json['name'],
      price: (json['price'] ?? 0.0).toDouble(),
      schemaVersion: 1,
      legacyFields: json,  // ä¿ç•™åŸå§‹æ•°æ®
    );
  }

  // ğŸ”„ æ•°æ®æ ¼å¼è½¬æ¢
  Map<String, dynamic> toJson() {
    final json = {
      'code': code,
      'name': name,
      'price': price,
      'schemaVersion': schemaVersion,
    };

    // å‘åå…¼å®¹ï¼šä¿ç•™æ—§å­—æ®µå
    if (schemaVersion <= 1) {
      json['fund_code'] = code;
      json['fund_name'] = name;
    }

    return json;
  }
}
```

#### æ•°æ®è¿ç§»ç­–ç•¥
```dart
// ğŸ”„ æ•°æ®è¿ç§»ç®¡ç†å™¨
class DataMigrationManager {
  static const int CURRENT_SCHEMA_VERSION = 2;

  Future<void> migrateIfNeeded() async {
    final currentVersion = await _getStoredSchemaVersion();

    if (currentVersion < CURRENT_SCHEMA_VERSION) {
      await _performMigration(currentVersion, CURRENT_SCHEMA_VERSION);
      await _updateSchemaVersion(CURRENT_SCHEMA_VERSION);
    }
  }

  Future<void> _performMigration(int fromVersion, int toVersion) async {
    switch (fromVersion) {
      case 1:
        await _migrateFromV1ToV2();
        break;
      // æœªæ¥ç‰ˆæœ¬è¿ç§»é€»è¾‘
    }
  }

  Future<void> _migrateFromV1ToV2() async {
    // å…·ä½“çš„æ•°æ®è¿ç§»é€»è¾‘
    final oldData = await _loadV1Data();
    final newData = oldData.map((item) => _convertV1ToV2(item));
    await _saveV2Data(newData);
  }
}
```

---

## ğŸ—„ï¸ æ•°æ®åº“å…¼å®¹æ€§ä¿è¯

### 1. æ•°æ®åº“æ¶æ„ç‰ˆæœ¬æ§åˆ¶

#### è¡¨ç»“æ„å˜æ›´ç­–ç•¥
```dart
// ğŸ—„ï¸ æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†
class DatabaseSchemaManager {
  static const List<String> MIGRATION_SCRIPTS = [
    // v1 -> v2 è¿ç§»è„šæœ¬
    '''
    ALTER TABLE funds ADD COLUMN schema_version INTEGER DEFAULT 1;
    CREATE TABLE funds_new (
      code TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      price REAL,
      schema_version INTEGER DEFAULT 2,
      created_at INTEGER,
      updated_at INTEGER
    );

    -- æ•°æ®è¿ç§»
    INSERT INTO funds_new (code, name, price, schema_version, created_at)
    SELECT fund_code, fund_name, price, 1, created_at FROM funds;

    -- ä¿ç•™æ—§è¡¨ä½œä¸ºå¤‡ä»½
    ALTER TABLE funds RENAME TO funds_v1_backup;
    ALTER TABLE funds_new RENAME TO funds;
    ''',

    // v2 -> v3 è¿ç§»è„šæœ¬ï¼ˆæœªæ¥ï¼‰
    '''
    -- ä¸ºæœªæ¥æ‰©å±•é¢„ç•™
    '''
  ];

  Future<void> migrateDatabase() async {
    final currentVersion = await _getDatabaseVersion();
    final targetVersion = MIGRATION_SCRIPTS.length;

    for (int version = currentVersion; version < targetVersion; version++) {
      await _executeMigrationScript(MIGRATION_SCRIPTS[version]);
    }
  }
}
```

#### æ•°æ®å¤‡ä»½å’Œæ¢å¤ç­–ç•¥
```dart
// ğŸ’¾ æ•°æ®å¤‡ä»½ç®¡ç†å™¨
class DatabaseBackupManager {
  Future<void> createBackup() async {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final backupPath = 'backups/backup_$timestamp.db';

    // åˆ›å»ºå®Œæ•´å¤‡ä»½
    await _copyDatabase(backupPath);

    // è®°å½•å¤‡ä»½ä¿¡æ¯
    await _recordBackup({
      'timestamp': timestamp,
      'path': backupPath,
      'schema_version': await _getDatabaseVersion(),
      'data_count': await _getDataCount(),
    });
  }

  Future<bool> restoreFromBackup(String backupPath) async {
    try {
      // éªŒè¯å¤‡ä»½æ–‡ä»¶
      final isValid = await _validateBackup(backupPath);
      if (!isValid) return false;

      // åˆ›å»ºå½“å‰çŠ¶æ€çš„å¤‡ä»½
      await createBackup();

      // æ¢å¤æ•°æ®
      await _restoreDatabase(backupPath);

      return true;
    } catch (e) {
      logger.error('æ¢å¤å¤‡ä»½å¤±è´¥: $e');
      return false;
    }
  }
}
```

### 2. ç¼“å­˜å…¼å®¹æ€§ç­–ç•¥

#### ç¼“å­˜æ•°æ®æ ¼å¼è¿ç§»
```dart
// ğŸ—„ï¸ ç¼“å­˜å…¼å®¹æ€§ç®¡ç†
class CacheCompatibilityManager {
  Future<void> migrateCacheData() async {
    final cacheBox = await Hive.openBox('cache_data');

    // æ£€æŸ¥ç¼“å­˜ç‰ˆæœ¬
    final cacheVersion = cacheBox.get('cache_schema_version') ?? 1;

    if (cacheVersion < 2) {
      await _migrateCacheDataV1ToV2(cacheBox);
      await cacheBox.put('cache_schema_version', 2);
    }
  }

  Future<void> _migrateCacheDataV1ToV2(Box cacheBox) async {
    final keys = cacheBox.keys.where((k) => k != 'cache_schema_version');

    for (final key in keys) {
      final data = cacheBox.get(key);
      if (data is Map && data.containsKey('legacy_data')) {
        // è½¬æ¢æ—§æ ¼å¼æ•°æ®
        final newData = _convertLegacyCacheData(data);
        await cacheBox.put(key, newData);
      }
    }
  }

  Map<String, dynamic> _convertLegacyCacheData(Map<String, dynamic> legacyData) {
    return {
      'data': legacyData['legacy_data'],
      'version': 2,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'ttl': legacyData['ttl'] ?? 3600,
    };
  }
}
```

---

## ğŸ”§ åŠŸèƒ½å…¼å®¹æ€§ä¿è¯

### 1. åŠŸèƒ½å¼€å…³æœºåˆ¶

#### æ¸è¿›å¼åŠŸèƒ½å‘å¸ƒ
```dart
// ğŸ›ï¸ åŠŸèƒ½å¼€å…³ç®¡ç†å™¨
class FeatureToggleManager {
  static const Map<String, bool> DEFAULT_FEATURES = {
    'unified_cache': false,      // é»˜è®¤å…³é—­ï¼Œé€æ­¥å¯ç”¨
    'new_data_source': false,    // é»˜è®¤å…³é—­
    'optimized_state': false,    // é»˜è®¤å…³é—­
  };

  final Box<FeatureToggle> _featureBox;

  Future<bool> isEnabled(String featureName) async {
    final toggle = await _featureBox.get(featureName);
    if (toggle != null) return toggle.enabled;

    // ä»è¿œç¨‹é…ç½®è·å–
    final remoteConfig = await _getRemoteFeatureConfig(featureName);
    return remoteConfig ?? DEFAULT_FEATURES[featureName] ?? false;
  }

  Future<void> enableFeature(String featureName, {bool enabled = true}) async {
    final toggle = FeatureToggle()
      ..name = featureName
      ..enabled = enabled
      ..enabledAt = DateTime.now();

    await _featureBox.put(featureName, toggle);
  }

  // ğŸ”„ æ¸è¿›å¼å¯ç”¨ç­–ç•¥
  Future<void> enableFeatureGradually(String featureName) async {
    final userSegment = await _getUserSegment();
    final enableThreshold = _getEnableThreshold(featureName);

    if (userSegment <= enableThreshold) {
      await enableFeature(featureName);
    }
  }
}
```

#### åŠŸèƒ½é€‚é…å™¨å®ç°
```dart
// ğŸ”„ åŠŸèƒ½é€‚é…å™¨
class CacheServiceAdapter implements ICacheService {
  final FeatureToggleManager _featureToggle;
  final ICacheService _legacyService;
  final ICacheService _newService;

  CacheServiceAdapter(
    this._featureToggle,
    this._legacyService,
    this._newService,
  );

  @override
  Future<T?> get<T>(String key) async {
    final useNewCache = await _featureToggle.isEnabled('unified_cache');

    if (useNewCache) {
      return await _newService.get<T>(key);
    } else {
      return await _legacyService.get<T>(key);
    }
  }

  @override
  Future<void> put<T>(String key, T data, {Duration? ttl}) async {
    final useNewCache = await _featureToggle.isEnabled('unified_cache');

    if (useNewCache) {
      await _newService.put(key, data, ttl: ttl);
    } else {
      await _legacyService.put(key, data, ttl: ttl);
    }
  }
}
```

### 2. ç”¨æˆ·ä½“éªŒå…¼å®¹æ€§

#### UI æ¸è¿›å¼æ›´æ–°
```dart
// ğŸ¨ UI å…¼å®¹æ€§ç®¡ç†å™¨
class UICompatibilityManager {
  Future<Widget> getCompatibleWidget(String widgetName) async {
    final useNewUI = await _featureToggle.isEnabled('new_ui_design');

    switch (widgetName) {
      case 'fund_card':
        return useNewUI ? _buildNewFundCard() : _buildLegacyFundCard();
      case 'search_bar':
        return useNewUI ? _buildNewSearchBar() : _buildLegacySearchBar();
      default:
        return _buildLegacyWidget(widgetName);
    }
  }

  Widget _buildLegacyFundCard() {
    // ä¿æŒåŸæœ‰ UI ä¸å˜
    return LegacyFundCardWidget();
  }

  Widget _buildNewFundCard() {
    // æ–°çš„ UI è®¾è®¡
    return EnhancedFundCardWidget();
  }
}
```

---

## ğŸ§ª å…¼å®¹æ€§æµ‹è¯•ç­–ç•¥

### 1. è‡ªåŠ¨åŒ–å…¼å®¹æ€§æµ‹è¯•

#### API å…¼å®¹æ€§æµ‹è¯•
```dart
// ğŸ§ª API å…¼å®¹æ€§æµ‹è¯•å¥—ä»¶
class APICompatibilityTest {
  late IFundService _legacyService;
  late IFundService _newService;

  @SetUp
  void setUp() {
    _legacyService = LegacyFundService();
    _newService = NewFundService();
  }

  @Test
  void testGetFundListCompatibility() async {
    final query = 'åŸºé‡‘';

    // æµ‹è¯•æ—§æ¥å£
    final legacyResult = await _legacyService.getFundList(query);

    // æµ‹è¯•æ–°æ¥å£ï¼ˆä½¿ç”¨å…¼å®¹æ€§å‚æ•°ï¼‰
    final newResult = await (_newService as IFundServiceV2)
        .getFundList(query, useCache: true);

    // éªŒè¯ç»“æœä¸€è‡´æ€§
    expect(legacyResult.length, equals(newResult.length));
    for (int i = 0; i < legacyResult.length; i++) {
      expect(legacyResult[i].code, equals(newResult[i].code));
      expect(legacyResult[i].name, equals(newResult[i].name));
    }
  }

  @Test
  void testBackwardCompatibility() async {
    // æµ‹è¯•æ–°ç³»ç»Ÿèƒ½å¦å¤„ç†æ—§æ ¼å¼æ•°æ®
    final legacyData = _createLegacyFundData();
    final convertedData = FundData.fromLegacyJson(legacyData);

    expect(convertedData.code, equals(legacyData['fund_code']));
    expect(convertedData.name, equals(legacyData['fund_name']));
    expect(convertedData.schemaVersion, equals(1));
  }
}
```

#### æ•°æ®åº“å…¼å®¹æ€§æµ‹è¯•
```dart
// ğŸ—„ï¸ æ•°æ®åº“å…¼å®¹æ€§æµ‹è¯•
class DatabaseCompatibilityTest {
  @Test
  void testDatabaseMigration() async {
    // åˆ›å»º v1 æ•°æ®åº“
    await _createV1Database();
    final v1Data = await _readV1Data();

    // æ‰§è¡Œè¿ç§»
    final migrationManager = DatabaseSchemaManager();
    await migrationManager.migrateDatabase();

    // éªŒè¯è¿ç§»ç»“æœ
    final v2Data = await _readV2Data();
    expect(v2Data.length, equals(v1Data.length));

    // éªŒè¯æ•°æ®å®Œæ•´æ€§
    for (int i = 0; i < v1Data.length; i++) {
      expect(v2Data[i].code, equals(v1Data[i]['fund_code']));
      expect(v2Data[i].schemaVersion, equals(2));
    }
  }

  @Test
  void testRollbackCapability() async {
    // æµ‹è¯•å›æ»šèƒ½åŠ›
    await _createV2Database();
    final backupManager = DatabaseBackupManager();

    // åˆ›å»ºå¤‡ä»½
    await backupManager.createBackup();

    // æ‰§è¡Œä¸€äº›å˜æ›´
    await _makeSomeChanges();

    // å›æ»šåˆ°å¤‡ä»½
    final backups = await backupManager.getAvailableBackups();
    await backupManager.restoreFromBackup(backups.first.path);

    // éªŒè¯å›æ»šæˆåŠŸ
    final currentData = await _readCurrentData();
    final originalData = await _readBackupData(backups.first.path);
    expect(currentData, equals(originalData));
  }
}
```

### 2. ç«¯åˆ°ç«¯å…¼å®¹æ€§æµ‹è¯•

#### ç”¨æˆ·åœºæ™¯å…¼å®¹æ€§æµ‹è¯•
```dart
// ğŸ­ ç«¯åˆ°ç«¯å…¼å®¹æ€§æµ‹è¯•
class E2ECompatibilityTest {
  @Test
  void testUserWorkflowCompatibility() async {
    // æ¨¡æ‹Ÿå…¸å‹ç”¨æˆ·å·¥ä½œæµ
    final app = await _initializeApp();

    // æµ‹è¯•åŸºé‡‘æœç´¢å·¥ä½œæµ
    await _testFundSearchWorkflow(app);

    // æµ‹è¯•åŸºé‡‘è¯¦æƒ…æŸ¥çœ‹å·¥ä½œæµ
    await _testFundDetailWorkflow(app);

    // æµ‹è¯•æ•°æ®åˆ·æ–°å·¥ä½œæµ
    await _testDataRefreshWorkflow(app);

    // éªŒè¯æ‰€æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ
    expect(app.crashes, isEmpty);
    expect(app.dataErrors, isEmpty);
  }

  Future<void> _testFundSearchWorkflow(TestApp app) async {
    // ä½¿ç”¨æ–°æ—§ä¸¤ç§æ–¹å¼æµ‹è¯•æœç´¢
    await app.tapSearchBar();
    await app.typeSearchQuery('æ··åˆåŸºé‡‘');
    await app.tapSearch();

    // éªŒè¯æœç´¢ç»“æœ
    expect(app.searchResults, isNotEmpty);
    expect(app.searchResults.first.name, contains('æ··åˆ'));
  }
}
```

---

## ğŸš¨ å…¼å®¹æ€§é—®é¢˜ç›‘æ§å’Œå‘Šè­¦

### 1. å®æ—¶ç›‘æ§æŒ‡æ ‡

#### å…³é”®å…¼å®¹æ€§æŒ‡æ ‡
```dart
// ğŸ“Š å…¼å®¹æ€§ç›‘æ§ç®¡ç†å™¨
class CompatibilityMonitor {
  static const List<String> COMPATIBILITY_METRICS = [
    'api_compatibility_errors',
    'data_migration_errors',
    'ui_rendering_errors',
    'feature_toggle_failures',
    'performance_regression',
  ];

  Future<void> startMonitoring() async {
    for (final metric in COMPATIBILITY_METRICS) {
      _monitorMetric(metric);
    }
  }

  void _monitorMetric(String metricName) {
    // å®æ—¶ç›‘æ§å…¼å®¹æ€§æŒ‡æ ‡
    Timer.periodic(Duration(minutes: 5), (timer) async {
      final value = await _getMetricValue(metricName);

      if (_isThresholdExceeded(metricName, value)) {
        await _sendAlert(metricName, value);
      }
    });
  }

  bool _isThresholdExceeded(String metric, dynamic value) {
    final thresholds = {
      'api_compatibility_errors': 5,      // 5ä¸ªé”™è¯¯/å°æ—¶
      'data_migration_errors': 1,         // 1ä¸ªé”™è¯¯/å¤©
      'ui_rendering_errors': 10,          // 10ä¸ªé”™è¯¯/å°æ—¶
      'performance_regression': 20.0,     // 20%æ€§èƒ½ä¸‹é™
    };

    return value > thresholds[metric] ?? 0;
  }

  Future<void> _sendAlert(String metric, dynamic value) async {
    final alert = CompatibilityAlert(
      metric: metric,
      value: value,
      timestamp: DateTime.now(),
      severity: _calculateSeverity(metric, value),
    );

    await _notificationService.sendAlert(alert);
    await _logService.logError('å…¼å®¹æ€§å‘Šè­¦: $metric = $value');
  }
}
```

### 2. è‡ªåŠ¨åŒ–å‘Šè­¦å’Œå“åº”

#### å‘Šè­¦å¤„ç†æœºåˆ¶
```dart
// ğŸš¨ å‘Šè­¦å¤„ç†ç³»ç»Ÿ
class AlertHandlingSystem {
  Future<void> handleCompatibilityAlert(CompatibilityAlert alert) async {
    switch (alert.severity) {
      case AlertSeverity.critical:
        await _handleCriticalAlert(alert);
        break;
      case AlertSeverity.warning:
        await _handleWarningAlert(alert);
        break;
      case AlertSeverity.info:
        await _logInfoAlert(alert);
        break;
    }
  }

  Future<void> _handleCriticalAlert(CompatibilityAlert alert) async {
    // ç«‹å³å›æ»šåˆ°å®‰å…¨çŠ¶æ€
    await _emergencyRollback();

    // é€šçŸ¥å¼€å‘å›¢é˜Ÿ
    await _notifyDevelopmentTeam(alert);

    // åˆ›å»ºé—®é¢˜è·Ÿè¸ª
    await _createIssueTicket(alert);

    // æš‚åœç›¸å…³åŠŸèƒ½
    await _disableAffectedFeatures(alert);
  }

  Future<void> _emergencyRollback() async {
    // ç´§æ€¥å›æ»šåˆ°ä¸Šä¸€ä¸ªç¨³å®šç‰ˆæœ¬
    final rollbackManager = RollbackManager();
    await rollbackManager.rollbackToLastStableVersion();
  }

  Future<void> _disableAffectedFeatures(CompatibilityAlert alert) async {
    final featureToggle = FeatureToggleManager();

    switch (alert.metric) {
      case 'api_compatibility_errors':
        await featureToggle.enableFeature('unified_cache', enabled: false);
        break;
      case 'data_migration_errors':
        await featureToggle.enableFeature('new_data_source', enabled: false);
        break;
      case 'ui_rendering_errors':
        await featureToggle.enableFeature('new_ui_design', enabled: false);
        break;
    }
  }
}
```

---

## ğŸ“‹ å…¼å®¹æ€§æ£€æŸ¥æ¸…å•

### å¼€å‘é˜¶æ®µæ£€æŸ¥æ¸…å•
```markdown
## ğŸ“‹ å¼€å‘å…¼å®¹æ€§æ£€æŸ¥æ¸…å•

### ä»£ç å˜æ›´å‰
- [ ] è¯„ä¼°å¯¹ç°æœ‰ API çš„å½±å“
- [ ] è¯†åˆ«å¯èƒ½çš„æ•°æ®æ ¼å¼å˜æ›´
- [ ] åˆ¶å®šå…¼å®¹æ€§ä¿è¯æ–¹æ¡ˆ
- [ ] å‡†å¤‡å›æ»šè®¡åˆ’

### ä»£ç å®ç°ä¸­
- [ ] ä½¿ç”¨é€‚é…å™¨æ¨¡å¼éš”ç¦»å˜æ›´
- [ ] ä¿æŒå…¬å…±æ¥å£ä¸å˜
- [ ] æ·»åŠ ç‰ˆæœ¬æ§åˆ¶å’Œå¼ƒç”¨æ ‡è®°
- [ ] å®ç°æ¸è¿›å¼è¿ç§»æœºåˆ¶

### ä»£ç æµ‹è¯•ä¸­
- [ ] è¿è¡Œå®Œæ•´çš„å…¼å®¹æ€§æµ‹è¯•å¥—ä»¶
- [ ] éªŒè¯æ–°æ—§ç³»ç»Ÿæ•°æ®ä¸€è‡´æ€§
- [ ] æµ‹è¯•å›æ»šå’Œæ¢å¤æœºåˆ¶
- [ ] éªŒè¯æ€§èƒ½æ— æ˜¾è‘—ä¸‹é™

### ä»£ç å‘å¸ƒå‰
- [ ] å®Œæˆå…¼å®¹æ€§å®¡æŸ¥
- [ ] å‡†å¤‡ç”¨æˆ·è¿ç§»æŒ‡å—
- [ ] è®¾ç½®ç›‘æ§å’Œå‘Šè­¦
- [ ] åˆ¶å®šåº”æ€¥å“åº”è®¡åˆ’
```

### å‘å¸ƒé˜¶æ®µæ£€æŸ¥æ¸…å•
```markdown
## ğŸš€ å‘å¸ƒå…¼å®¹æ€§æ£€æŸ¥æ¸…å•

### å‘å¸ƒå‡†å¤‡
- [ ] åˆ›å»ºå®Œæ•´çš„æ•°æ®å¤‡ä»½
- [ ] éªŒè¯æ‰€æœ‰å…¼å®¹æ€§æµ‹è¯•é€šè¿‡
- [ ] ç¡®è®¤ç›‘æ§æŒ‡æ ‡æ­£å¸¸
- [ ] å‡†å¤‡å¿«é€Ÿå›æ»šæ–¹æ¡ˆ

### æ¸è¿›å¼å‘å¸ƒ
- [ ] å°èŒƒå›´ç”¨æˆ·æµ‹è¯•
- [ ] ç›‘æ§å…³é”®æŒ‡æ ‡å˜åŒ–
- [ ] æ”¶é›†ç”¨æˆ·åé¦ˆ
- [ ] é€æ­¥æ‰©å¤§å‘å¸ƒèŒƒå›´

### å‘å¸ƒåéªŒè¯
- [ ] ç¡®è®¤æ‰€æœ‰åŠŸèƒ½æ­£å¸¸
- [ ] éªŒè¯ç”¨æˆ·æ•°æ®å®Œæ•´æ€§
- [ ] æ£€æŸ¥æ€§èƒ½æŒ‡æ ‡ç¨³å®š
- [ ] æ›´æ–°å…¼å®¹æ€§æ–‡æ¡£

### åº”æ€¥å“åº”
- [ ] ç›‘æ§å‘Šè­¦ç³»ç»ŸçŠ¶æ€
- [ ] å¿«é€Ÿå“åº”å…¼å®¹æ€§é—®é¢˜
- [ ] å¿…è¦æ—¶æ‰§è¡Œå›æ»š
- [ ] åˆ†æå’Œä¿®å¤é—®é¢˜
```

---

## ğŸ“š å…¼å®¹æ€§æ–‡æ¡£å’ŒåŸ¹è®­

### 1. å¼€å‘è€…æŒ‡å—

#### å…¼å®¹æ€§å¼€å‘æœ€ä½³å®è·µ
```markdown
# å…¼å®¹æ€§å¼€å‘æŒ‡å—

## ğŸ“ ç¼–ç è§„èŒƒ

### æ¥å£è®¾è®¡
- å…¬å…±æ¥å£ä¸€æ—¦å‘å¸ƒï¼Œä¸å…è®¸ç ´åæ€§å˜æ›´
- æ–°åŠŸèƒ½ä½¿ç”¨å¯é€‰å‚æ•°æˆ–é‡è½½æ–¹æ³•
- ä½¿ç”¨ @Deprecated æ ‡è®°è¿‡æ—¶æ¥å£

### æ•°æ®å¤„ç†
- ä¿æŒæ•°æ®æ ¼å¼å‘åå…¼å®¹
- ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶ç®¡ç†æ•°æ®æ¨¡å‹
- å®ç°è‡ªåŠ¨æ•°æ®è¿ç§»æœºåˆ¶

### åŠŸèƒ½å®ç°
- ä½¿ç”¨åŠŸèƒ½å¼€å…³æ§åˆ¶æ–°åŠŸèƒ½å‘å¸ƒ
- å®ç°é€‚é…å™¨æ¨¡å¼éš”ç¦»ç³»ç»Ÿå˜æ›´
- ä¿æŒç”¨æˆ·ä½“éªŒè¿ç»­æ€§
```

### 2. ç”¨æˆ·è¿ç§»æŒ‡å—

#### åŠŸèƒ½å˜æ›´é€šçŸ¥
```markdown
# ç”¨æˆ·åŠŸèƒ½å˜æ›´é€šçŸ¥

## ğŸ“¢ æ–°åŠŸèƒ½å‘å¸ƒé€šçŸ¥

### ç¼“å­˜ç³»ç»Ÿå‡çº§
- **å‘å¸ƒæ—¶é—´**: 2025-11-15
- **å½±å“èŒƒå›´**: åŸºé‡‘æœç´¢å’Œæ•°æ®åŠ è½½
- **ç”¨æˆ·å½±å“**: æœç´¢é€Ÿåº¦æå‡ 30%
- **å…¼å®¹æ€§**: å®Œå…¨å‘åå…¼å®¹ï¼Œæ— éœ€ç”¨æˆ·æ“ä½œ

### æ•°æ®æºä¼˜åŒ–
- **å‘å¸ƒæ—¶é—´**: 2025-12-01
- **å½±å“èŒƒå›´**: æ•°æ®æ›´æ–°å’ŒåŒæ­¥
- **ç”¨æˆ·å½±å“**: æ•°æ®æ›´æ–°æ›´åŠæ—¶
- **å…¼å®¹æ€§**: è‡ªåŠ¨æ•°æ®è¿ç§»ï¼Œæ— éœ€ç”¨æˆ·å¹²é¢„
```

---

## ğŸ¯ å…¼å®¹æ€§æˆåŠŸæ ‡å‡†

### æŠ€æœ¯æŒ‡æ ‡
- [ ] API å…¼å®¹æ€§é”™è¯¯ç‡ < 0.1%
- [ ] æ•°æ®è¿ç§»æˆåŠŸç‡ > 99.9%
- [ ] åŠŸèƒ½å›æ»šæ—¶é—´ < 5 åˆ†é’Ÿ
- [ ] å…¼å®¹æ€§æµ‹è¯•è¦†ç›–ç‡ 100%

### ä¸šåŠ¡æŒ‡æ ‡
- [ ] ç”¨æˆ·æŠ•è¯‰ç‡ < 0.5%
- [ ] åŠŸèƒ½ä½¿ç”¨ç‡æ— æ˜¾è‘—ä¸‹é™
- [ ] ç”¨æˆ·ä½“éªŒæ»¡æ„åº¦ä¿æŒç¨³å®š
- [ ] ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%

### è´¨é‡æŒ‡æ ‡
- [ ] é›¶ç ´åæ€§å˜æ›´
- [ ] å®Œæ•´çš„å›æ»šæœºåˆ¶
- [ ] å®æ—¶ç›‘æ§è¦†ç›–
- [ ] å¿«é€Ÿå“åº”èƒ½åŠ›

---

*æœ¬å…¼å®¹æ€§ä¿è¯ç­–ç•¥å°†æ ¹æ®é¡¹ç›®å®æ–½è¿‡ç¨‹ä¸­çš„ç»éªŒæ•™è®­æŒç»­æ”¹è¿›å’Œå®Œå–„*