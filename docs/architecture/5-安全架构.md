# 5. å®‰å…¨æ¶æ„

## ğŸ”’ å®‰å…¨æ¶æ„æ¦‚è¿°

åŸºé€ŸåŸºé‡‘é‡åŒ–åˆ†æå¹³å°ä½œä¸ºé‡‘èç§‘æŠ€åº”ç”¨ï¼Œå®‰å…¨æ˜¯æ¶æ„è®¾è®¡çš„æ ¸å¿ƒè¦ç´ ã€‚æœ¬ç« èŠ‚è¯¦ç»†é˜è¿°å¹³å°çš„å®‰å…¨æ¶æ„è®¾è®¡ï¼ŒåŒ…æ‹¬æ•°æ®å®‰å…¨ã€ç½‘ç»œå®‰å…¨ã€è®¿é—®æ§åˆ¶ã€åˆè§„æ€§ç®¡ç†ç­‰å„ä¸ªå±‚é¢çš„å®‰å…¨ä¿éšœæªæ–½ã€‚

### 5.1 å®‰å…¨æ¶æ„ç›®æ ‡

#### 5.1.1 æ ¸å¿ƒå®‰å…¨ç›®æ ‡

**æœºå¯†æ€§ (Confidentiality)**
- ç¡®ä¿ç”¨æˆ·æ•°æ®å’Œé‡‘èä¿¡æ¯çš„æœºå¯†æ€§
- é˜²æ­¢æ•æ„Ÿä¿¡æ¯æ³„éœ²ç»™æœªæˆæƒæ–¹
- ä¿æŠ¤ç”¨æˆ·éšç§å’ŒæŠ•èµ„å†³ç­–ä¿¡æ¯

**å®Œæ•´æ€§ (Integrity)**
- ç¡®ä¿é‡‘èæ•°æ®çš„å®Œæ•´æ€§å’Œå‡†ç¡®æ€§
- é˜²æ­¢æ•°æ®è¢«æœªæˆæƒä¿®æ”¹æˆ–ç ´å
- ä¿è¯ç³»ç»ŸåŠŸèƒ½çš„æ­£ç¡®æ€§

**å¯ç”¨æ€§ (Availability)**
- ç¡®ä¿ç³»ç»ŸæœåŠ¡çš„æŒç»­å¯ç”¨æ€§
- é˜²æ­¢æœåŠ¡æ‹’ç»æ”»å‡»å½±å“ä¸šåŠ¡è¿è¥
- ä¿è¯ç”¨æˆ·èƒ½å¤Ÿæ­£å¸¸è®¿é—®ç³»ç»ŸåŠŸèƒ½

**å¯å®¡è®¡æ€§ (Accountability)**
- è®°å½•æ‰€æœ‰å…³é”®æ“ä½œå’Œè®¿é—®è¡Œä¸º
- æä¾›å®Œæ•´çš„å®¡è®¡è¿½è¸ªèƒ½åŠ›
- æ”¯æŒå®‰å…¨äº‹ä»¶çš„è°ƒæŸ¥å’Œåˆ†æ

#### 5.1.2 å®‰å…¨è®¾è®¡åŸåˆ™

**æ·±åº¦é˜²å¾¡ (Defense in Depth)**
```yaml
security_layers:
  - network_layer: ç½‘ç»œå±‚é¢çš„å®‰å…¨é˜²æŠ¤
  - application_layer: åº”ç”¨ç¨‹åºå®‰å…¨æœºåˆ¶
  - data_layer: æ•°æ®å­˜å‚¨å’Œä¼ è¾“å®‰å…¨
  - infrastructure_layer: åŸºç¡€è®¾æ–½å®‰å…¨æªæ–½
  - physical_layer: ç‰©ç†ç¯å¢ƒå®‰å…¨ä¿æŠ¤
```

**æœ€å°æƒé™åŸåˆ™ (Principle of Least Privilege)**
- ç”¨æˆ·å’Œç³»ç»Ÿåªè·å¾—å®Œæˆå…¶ä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
- å®æ–½åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰
- å®šæœŸå®¡æŸ¥å’Œè°ƒæ•´æƒé™åˆ†é…

**å®‰å…¨é»˜è®¤ (Secure by Default)**
- ç³»ç»Ÿé»˜è®¤é…ç½®ä¸ºæœ€å®‰å…¨çŠ¶æ€
- éœ€è¦æ˜ç¡®æˆæƒæ‰èƒ½é™ä½å®‰å…¨çº§åˆ«
- æ‰€æœ‰å®‰å…¨ç»„ä»¶é»˜è®¤å¯ç”¨

### 5.2 ç½‘ç»œå®‰å…¨æ¶æ„

#### 5.2.1 ç½‘ç»œå±‚æ¬¡å®‰å…¨

**ç½‘ç»œè¾¹ç•Œå®‰å…¨**
```yaml
network_security:
  # è¾¹ç•Œé˜²æŠ¤
  perimeter_security:
    - web_application_firewall: WAFé˜²æŠ¤
    - ddos_protection: DDoSæ”»å‡»é˜²æŠ¤
    - ssl_termination: SSLå¸è½½å’ŒåŠ é€Ÿ
    - network_access_control: ç½‘ç»œè®¿é—®æ§åˆ¶

  # åŒºåŸŸéš”ç¦»
  zone_separation:
    - dmz_zone: DMZåŒºåŸŸï¼ˆé¢å‘äº’è”ç½‘ï¼‰
    - application_zone: åº”ç”¨æœåŠ¡åŒºåŸŸ
    - database_zone: æ•°æ®åº“å­˜å‚¨åŒºåŸŸ
    - management_zone: ç®¡ç†åŒºåŸŸ
```

**ç½‘ç»œå®‰å…¨å®ç°**ï¼š
```python
# security/network_security.py - ç½‘ç»œå®‰å…¨é…ç½®
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
import ipaddress
from typing import Set

class NetworkSecurityManager:
    def __init__(self, app: FastAPI):
        self.app = app
        self.trusted_ips: Set[str] = set()
        self.blocked_ips: Set[str] = set()
        self.setup_security_middleware()

    def setup_security_middleware(self):
        """è®¾ç½®å®‰å…¨ä¸­é—´ä»¶"""

        # CORSé…ç½®
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=self._get_allowed_origins(),
            allow_credentials=True,
            allow_methods=["GET", "POST", "PUT", "DELETE"],
            allow_headers=["*"],
            max_age=3600,
        )

        # ä¿¡ä»»ä¸»æœºä¸­é—´ä»¶
        self.app.add_middleware(
            TrustedHostMiddleware,
            allowed_hosts=self._get_allowed_hosts()
        )

        # å®‰å…¨å¤´ä¸­é—´ä»¶
        self.app.middleware("http")(self._add_security_headers)

        # IPé»‘ç™½åå•ä¸­é—´ä»¶
        self.app.middleware("http")(self._ip_filter_middleware)

    def _add_security_headers(self, request: Request, call_next):
        """æ·»åŠ å®‰å…¨å¤´"""
        response = call_next(request)

        # å®‰å…¨å¤´è®¾ç½®
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "font-src 'self' https:; "
            "connect-src 'self' https:; "
            "media-src 'self' https:; "
            "object-src 'none'; "
            "base-uri 'self'; "
            "form-action 'self'; "
            "frame-ancestors 'none'; "
            "upgrade-insecure-requests"
        )

        return response

    async def _ip_filter_middleware(self, request: Request, call_next):
        """IPè¿‡æ»¤ä¸­é—´ä»¶"""
        client_ip = get_remote_address(request)

        # æ£€æŸ¥IPæ˜¯å¦åœ¨é»‘åå•ä¸­
        if client_ip in self.blocked_ips:
            raise HTTPException(status_code=403, detail="IP address blocked")

        # æ£€æŸ¥IPæ˜¯å¦åœ¨ç™½åå•ä¸­ï¼ˆå¦‚æœå¯ç”¨äº†ç™½åå•ï¼‰
        if self.trusted_ips and client_ip not in self.trusted_ips:
            raise HTTPException(status_code=403, detail="IP address not authorized")

        return await call_next(request)

    def _get_allowed_origins(self) -> list:
        """è·å–å…è®¸çš„åŸŸå"""
        return [
            "https://yourdomain.com",
            "https://app.yourdomain.com",
            "http://localhost:3000",  # å¼€å‘ç¯å¢ƒ
            "http://localhost:8080",
        ]

    def _get_allowed_hosts(self) -> list:
        """è·å–å…è®¸çš„ä¸»æœº"""
        return [
            "yourdomain.com",
            "app.yourdomain.com",
            "localhost",
            "127.0.0.1",
        ]

    def add_trusted_ip(self, ip: str):
        """æ·»åŠ ä¿¡ä»»IP"""
        try:
            # éªŒè¯IPåœ°å€æ ¼å¼
            ipaddress.ip_address(ip)
            self.trusted_ips.add(ip)
            logger.info(f"Added trusted IP: {ip}")
        except ValueError:
            raise ValueError(f"Invalid IP address: {ip}")

    def block_ip(self, ip: str):
        """å°ç¦IP"""
        try:
            ipaddress.ip_address(ip)
            self.blocked_ips.add(ip)
            logger.warning(f"Blocked IP: {ip}")
        except ValueError:
            raise ValueError(f"Invalid IP address: {ip}")
```

#### 5.2.2 APIå®‰å…¨é˜²æŠ¤

**APIå®‰å…¨ç­–ç•¥**ï¼š
```python
# security/api_security.py - APIå®‰å…¨
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional
import hashlib
import secrets

class APISecurityManager:
    def __init__(self):
        self.security = HTTPBearer()
        self.secret_key = secrets.token_urlsafe(32)
        self.algorithm = "HS256"
        self.access_token_expire_minutes = 30
        self.refresh_token_expire_days = 7

    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        to_encode = data.copy()

        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)

        to_encode.update({"exp": expire, "type": "access"})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    def create_refresh_token(self, data: dict):
        """åˆ›å»ºåˆ·æ–°ä»¤ç‰Œ"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(days=self.refresh_token_expire_days)
        to_encode.update({"exp": expire, "type": "refresh"})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    async def verify_token(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())):
        """éªŒè¯ä»¤ç‰Œ"""
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

        try:
            payload = jwt.decode(credentials.credentials, self.secret_key, algorithms=[self.algorithm])
            username: str = payload.get("sub")
            token_type: str = payload.get("type")

            if username is None or token_type != "access":
                raise credentials_exception

        except JWTError:
            raise credentials_exception

        return username

    def hash_password(self, password: str) -> str:
        """å¯†ç å“ˆå¸Œ"""
        salt = secrets.token_hex(16)
        pwdhash = hashlib.pbkdf2_hmac('sha256',
                                      password.encode('utf-8'),
                                      salt.encode('utf-8'),
                                      100000)
        return salt + pwdhash.hex()

    def verify_password(self, stored_password: str, provided_password: str) -> bool:
        """éªŒè¯å¯†ç """
        salt = stored_password[:32]
        stored_hash = stored_password[32:]
        pwdhash = hashlib.pbkdf2_hmac('sha256',
                                      provided_password.encode('utf-8'),
                                      salt.encode('utf-8'),
                                      100000)
        return pwdhash.hex() == stored_hash

# ä¾èµ–æ³¨å…¥ä½¿ç”¨ç¤ºä¾‹
security_manager = APISecurityManager()

async def get_current_user(token: str = Depends(security_manager.verify_token)):
    """è·å–å½“å‰ç”¨æˆ·"""
    # è¿™é‡Œå¯ä»¥ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯
    return {"username": token}

# è·¯ç”±ä¿æŠ¤ç¤ºä¾‹
@app.get("/protected-route")
async def protected_route(current_user: dict = Depends(get_current_user)):
    """éœ€è¦è®¤è¯çš„è·¯ç”±"""
    return {"message": f"Hello {current_user['username']}"}
```

### 5.3 æ•°æ®å®‰å…¨æ¶æ„

#### 5.3.1 æ•°æ®åŠ å¯†ç­–ç•¥

**æ•°æ®åˆ†ç±»å’ŒåŠ å¯†è¦æ±‚**ï¼š
```yaml
data_classification:
  # é«˜æ•æ„Ÿæ•°æ®
  highly_sensitive:
    - user_passwords: "AES-256 + PBKDF2"
    - financial_data: "AES-256"
    - personal_identification: "AES-256"
    - api_keys: "AES-256"
    encryption_at_rest: True
    encryption_in_transit: True

  # ä¸­ç­‰æ•æ„Ÿæ•°æ®
  medium_sensitive:
    - user_preferences: "AES-128"
    - app_usage_data: "AES-128"
    - analytics_data: "AES-128"
    encryption_at_rest: True
    encryption_in_transit: True

  # ä½æ•æ„Ÿæ•°æ®
  low_sensitive:
    - public_fund_data: "æ— åŠ å¯†"
    - general_app_data: "æ— åŠ å¯†"
    - cached_public_data: "æ— åŠ å¯†"
    encryption_at_rest: False
    encryption_in_transit: True
```

**åŠ å¯†å®ç°**ï¼š
```python
# security/encryption.py - æ•°æ®åŠ å¯†ç®¡ç†
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
import json
from typing import Any, Dict, Optional

class EncryptionManager:
    def __init__(self, master_key: Optional[str] = None):
        if master_key:
            self.master_key = master_key.encode()
        else:
            self.master_key = os.environ.get('ENCRYPTION_MASTER_KEY', '').encode()

        if not self.master_key:
            raise ValueError("Encryption master key is required")

        self.fernet = self._create_fernet()

    def _create_fernet(self) -> Fernet:
        """åˆ›å»ºFernetåŠ å¯†å™¨"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'jisu_platform_salt',  # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨éšæœºsalt
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        return Fernet(key)

    def encrypt_data(self, data: Any) -> str:
        """åŠ å¯†æ•°æ®"""
        if isinstance(data, (dict, list)):
            data_str = json.dumps(data, default=str)
        else:
            data_str = str(data)

        encrypted_data = self.fernet.encrypt(data_str.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()

    def decrypt_data(self, encrypted_data: str) -> Any:
        """è§£å¯†æ•°æ®"""
        try:
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = self.fernet.decrypt(encrypted_bytes).decode()

            # å°è¯•è§£æä¸ºJSON
            try:
                return json.loads(decrypted_data)
            except json.JSONDecodeError:
                return decrypted_data

        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise ValueError("Failed to decrypt data")

    def encrypt_sensitive_field(self, value: str, field_type: str) -> Dict[str, str]:
        """åŠ å¯†æ•æ„Ÿå­—æ®µ"""
        encrypted_value = self.encrypt_data(value)
        return {
            "encrypted": encrypted_value,
            "field_type": field_type,
            "encryption_version": "v1"
        }

    def decrypt_sensitive_field(self, field_data: Dict[str, str]) -> str:
        """è§£å¯†æ•æ„Ÿå­—æ®µ"""
        if not field_data.get("encrypted"):
            return ""

        try:
            return self.decrypt_data(field_data["encrypted"])
        except Exception:
            logger.error(f"Failed to decrypt field of type: {field_data.get('field_type')}")
            return ""

# æ•°æ®åº“å­—æ®µåŠ å¯†è£…é¥°å™¨
from functools import wraps
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import JSONB

class EncryptedField(sa.TypeDecorator):
    """SQLAlchemyåŠ å¯†å­—æ®µç±»å‹"""
    impl = sa.Text
    cache_ok = True

    def __init__(self, encryption_manager: EncryptionManager, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_manager = encryption_manager

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        return self.encryption_manager.encrypt_data(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return self.encryption_manager.decrypt_data(value)

# æ•°æ®åº“æ¨¡å‹ä½¿ç”¨ç¤ºä¾‹
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
encryption_manager = EncryptionManager()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(EncryptedField(encryption_manager), nullable=False)
    phone = Column(EncryptedField(encryption_manager))
    financial_data = Column(EncryptedField(encryption_manager))
```

#### 5.3.2 æ•°æ®ä¼ è¾“å®‰å…¨

**HTTPSé…ç½®å’Œè¯ä¹¦ç®¡ç†**ï¼š
```python
# security/ssl_manager.py - SSL/TLSç®¡ç†
import ssl
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import socket
import subprocess
from datetime import datetime, timedelta

class SSLManager:
    def __init__(self):
        self.cert_path = "/etc/ssl/certs/jisu.crt"
        self.key_path = "/etc/ssl/private/jisu.key"
        self.ca_path = "/etc/ssl/certs/ca-bundle.crt"

    def create_ssl_context(self) -> ssl.SSLContext:
        """åˆ›å»ºSSLä¸Šä¸‹æ–‡"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

        # å¼ºåˆ¶ä½¿ç”¨TLS 1.2æˆ–æ›´é«˜ç‰ˆæœ¬
        context.minimum_version = ssl.TLSVersion.TLSv1_2

        # è®¾ç½®åŠ å¯†å¥—ä»¶
        context.set_ciphers(
            'ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS'
        )

        # å¯ç”¨è¯ä¹¦éªŒè¯
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True

        # åŠ è½½è¯ä¹¦å’Œç§é’¥
        try:
            context.load_cert_chain(self.cert_path, self.key_path)
            context.load_verify_locations(self.ca_path)
        except FileNotFoundError as e:
            logger.error(f"SSL certificate not found: {e}")
            raise

        # è®¾ç½®HTTP/2æ”¯æŒ
        try:
            context.set_alpn_protocols(['h2', 'http/1.1'])
        except AttributeError:
            logger.warning("ALPN protocols not supported")

        return context

    def verify_certificate(self, host: str, port: int = 443) -> bool:
        """éªŒè¯SSLè¯ä¹¦"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED

            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert(binary_form=True)
                    x509_cert = x509.load_der_x509_certificate(cert, default_backend())

                    # æ£€æŸ¥è¯ä¹¦æœ‰æ•ˆæœŸ
                    if datetime.utcnow() > x509_cert.not_valid_after:
                        logger.warning(f"Certificate for {host} has expired")
                        return False

                    # æ£€æŸ¥è¯ä¹¦ä¸»é¢˜
                    subject = x509_cert.subject
                    common_name = None
                    for attr in subject:
                        if attr.oid == x509.NameOID.COMMON_NAME:
                            common_name = attr.value
                            break

                    if common_name != host:
                        logger.warning(f"Certificate CN ({common_name}) does not match host ({host})")
                        return False

            return True

        except Exception as e:
            logger.error(f"Certificate verification failed for {host}: {e}")
            return False

    def generate_self_signed_cert(self, domains: list, key_size: int = 2048):
        """ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼ˆå¼€å‘ç¯å¢ƒä½¿ç”¨ï¼‰"""
        from cryptography.hazmat.primitives import hashes
        from cryptography.hazmat.primitives.asymmetric import rsa
        from cryptography.x509.oid import NameOID

        # ç”Ÿæˆç§é’¥
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )

        # åˆ›å»ºè¯ä¹¦ä¸»é¢˜
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Beijing"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Beijing"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Jisu Platform"),
            x509.NameAttribute(NameOID.COMMON_NAME, domains[0]),
        ])

        # åˆ›å»ºè¯ä¹¦
        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=365)
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(domain) for domain in domains
            ])
        ).sign(private_key, hashes.SHA256(), default_backend())

        # ä¿å­˜è¯ä¹¦å’Œç§é’¥
        with open(self.cert_path, "wb") as f:
            f.write(cert.public_bytes(serialization.Encoding.PEM))

        with open(self.key_path, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ))

        logger.info(f"Self-signed certificate generated for domains: {domains}")

# FastAPI SSLé…ç½®
from fastapi import FastAPI
import uvicorn

ssl_manager = SSLManager()

app = FastAPI()

if __name__ == "__main__":
    # ç”Ÿäº§ç¯å¢ƒSSLé…ç½®
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=443,
        ssl_keyfile=ssl_manager.key_path,
        ssl_certfile=ssl_manager.cert_path,
        ssl_version=ssl.PROTOCOL_TLS,
        ssl_ciphers="ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20",
    )
```

### 5.4 èº«ä»½è®¤è¯ä¸æˆæƒ

#### 5.4.1 å¤šå› ç´ è®¤è¯æ¶æ„

**MFAå®ç°æ–¹æ¡ˆ**ï¼š
```python
# security/mfa_manager.py - å¤šå› ç´ è®¤è¯
import pyotp
import qrcode
from io import BytesIO
import base64
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from typing import Optional
import secrets

class MFAManager:
    def __init__(self):
        self.app_name = "åŸºé€ŸåŸºé‡‘å¹³å°"

    def generate_totp_secret(self, username: str) -> str:
        """ç”ŸæˆTOTPå¯†é’¥"""
        return pyotp.random_base32()

    def generate_qr_code(self, username: str, secret: str) -> str:
        """ç”ŸæˆQRç """
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=username,
            issuer_name=self.app_name
        )

        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")

        # è½¬æ¢ä¸ºbase64
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode()

        return f"data:image/png;base64,{img_str}"

    def verify_totp_token(self, secret: str, token: str) -> bool:
        """éªŒè¯TOTPä»¤ç‰Œ"""
        totp = pyotp.TOTP(secret)
        return totp.verify(token, valid_window=1)  # å…è®¸æ—¶é—´çª—å£å‰å30ç§’

    def generate_backup_codes(self, count: int = 10) -> list:
        """ç”Ÿæˆå¤‡ç”¨æ¢å¤ç """
        return [secrets.token_hex(4).upper() for _ in range(count)]

    def send_sms_code(self, phone_number: str, code: str) -> bool:
        """å‘é€çŸ­ä¿¡éªŒè¯ç """
        try:
            # è¿™é‡Œé›†æˆçŸ­ä¿¡æœåŠ¡æä¾›å•†API
            # ç¤ºä¾‹ä½¿ç”¨é˜¿é‡Œäº‘çŸ­ä¿¡æœåŠ¡
            from aliyunsdkcore.client import AcsClient
            from aliyunsdkcore.acs_exception.exceptions import ServerException
            from aliyunsdksms.request.v20170525 import SendSmsRequest

            client = AcsClient(
                'your-access-key-id',
                'your-access-key-secret',
                'cn-hangzhou'
            )

            request = SendSmsRequest()
            request.set_PhoneNumbers(phone_number)
            request.set_SignName("åŸºé€Ÿå¹³å°")
            request.set_TemplateCode("SMS_123456789")
            request.set_TemplateParam(f'{{"code":"{code}"}}')

            response = client.do_action_with_exception(request)
            return response.get('Code') == 'OK'

        except Exception as e:
            logger.error(f"Failed to send SMS: {e}")
            return False

    def send_email_code(self, email: str, code: str) -> bool:
        """å‘é€é‚®ä»¶éªŒè¯ç """
        try:
            msg = MimeMultipart()
            msg['From'] = 'noreply@jisu.com'
            msg['To'] = email
            msg['Subject'] = 'åŸºé€Ÿå¹³å°éªŒè¯ç '

            body = f"""
            æ‚¨çš„éªŒè¯ç æ˜¯ï¼š{code}

            è¯¥éªŒè¯ç 5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²ç»™ä»–äººã€‚

            åŸºé€ŸåŸºé‡‘é‡åŒ–åˆ†æå¹³å°
            """

            msg.attach(MimeText(body, 'plain'))

            # SMTPé…ç½®
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login('your-email@gmail.com', 'your-app-password')
            text = msg.as_string()
            server.sendmail('noreply@jisu.com', email, text)
            server.quit()

            return True

        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False

# è®¤è¯æœåŠ¡é›†æˆ
class AuthenticationService:
    def __init__(self):
        self.mfa_manager = MFAManager()
        self.user_sessions = {}

    async def setup_mfa(self, user_id: int, mfa_type: str) -> dict:
        """è®¾ç½®å¤šå› ç´ è®¤è¯"""
        if mfa_type == "totp":
            secret = self.mfa_manager.generate_totp_secret(f"user_{user_id}")
            qr_code = self.mfa_manager.generate_qr_code(f"user_{user_id}", secret)
            backup_codes = self.mfa_manager.generate_backup_codes()

            # ä¿å­˜åˆ°æ•°æ®åº“
            await self._save_mfa_setup(user_id, {
                "type": "totp",
                "secret": secret,
                "backup_codes": backup_codes,
                "verified": False
            })

            return {
                "qr_code": qr_code,
                "backup_codes": backup_codes,
                "setup_instructions": "è¯·ä½¿ç”¨Google Authenticatoræ‰«æQRç "
            }

        elif mfa_type == "sms":
            # å‘é€éªŒè¯çŸ­ä¿¡
            user_phone = await self._get_user_phone(user_id)
            code = f"{secrets.randbelow(1000000):06d}"

            if self.mfa_manager.send_sms_code(user_phone, code):
                await self._save_mfa_setup(user_id, {
                    "type": "sms",
                    "phone": user_phone,
                    "verified": False
                })
                return {"message": "éªŒè¯ç å·²å‘é€åˆ°æ‚¨çš„æ‰‹æœº"}
            else:
                raise Exception("çŸ­ä¿¡å‘é€å¤±è´¥")

        elif mfa_type == "email":
            # å‘é€éªŒè¯é‚®ä»¶
            user_email = await self._get_user_email(user_id)
            code = f"{secrets.randbelow(1000000):06d}"

            if self.mfa_manager.send_email_code(user_email, code):
                await self._save_mfa_setup(user_id, {
                    "type": "email",
                    "email": user_email,
                    "verified": False
                })
                return {"message": "éªŒè¯ç å·²å‘é€åˆ°æ‚¨çš„é‚®ç®±"}
            else:
                raise Exception("é‚®ä»¶å‘é€å¤±è´¥")

    async def verify_mfa(self, user_id: int, code: str) -> bool:
        """éªŒè¯å¤šå› ç´ è®¤è¯"""
        mfa_setup = await self._get_mfa_setup(user_id)

        if not mfa_setup:
            return False

        if mfa_setup["type"] == "totp":
            return self.mfa_manager.verify_totp_token(mfa_setup["secret"], code)

        elif mfa_setup["type"] in ["sms", "email"]:
            # éªŒè¯çŸ­ä¿¡æˆ–é‚®ä»¶éªŒè¯ç 
            return await self._verify_one_time_code(user_id, code)

        return False

    async def _save_mfa_setup(self, user_id: int, setup_data: dict):
        """ä¿å­˜MFAè®¾ç½®åˆ°æ•°æ®åº“"""
        # å®ç°æ•°æ®åº“ä¿å­˜é€»è¾‘
        pass

    async def _get_mfa_setup(self, user_id: int) -> Optional[dict]:
        """ä»æ•°æ®åº“è·å–MFAè®¾ç½®"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        pass

    async def _get_user_phone(self, user_id: int) -> str:
        """è·å–ç”¨æˆ·æ‰‹æœºå·"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        pass

    async def _get_user_email(self, user_id: int) -> str:
        """è·å–ç”¨æˆ·é‚®ç®±"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        pass

    async def _verify_one_time_code(self, user_id: int, code: str) -> bool:
        """éªŒè¯ä¸€æ¬¡æ€§éªŒè¯ç """
        # å®ç°éªŒè¯ç éªŒè¯é€»è¾‘
        pass
```

#### 5.4.2 åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)

**RBACæ¶æ„å®ç°**ï¼š
```python
# security/rbac.py - åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
from enum import Enum
from typing import List, Set, Dict, Optional
from dataclasses import dataclass
from fastapi import HTTPException, status

class Permission(Enum):
    # ç”¨æˆ·ç®¡ç†æƒé™
    READ_USERS = "read:users"
    WRITE_USERS = "write:users"
    DELETE_USERS = "delete:users"

    # åŸºé‡‘æ•°æ®æƒé™
    READ_FUNDS = "funds:read"
    WRITE_FUNDS = "funds:write"
    ANALYZE_FUNDS = "funds:analyze"

    # åˆ†æå·¥å…·æƒé™
    USE_BASIC_ANALYSIS = "analysis:basic"
    USE_ADVANCED_ANALYSIS = "analysis:advanced"

    # æŠ•èµ„ç»„åˆæƒé™
    CREATE_PORTFOLIOS = "portfolios:create"
    MANAGE_PORTFOLIOS = "portfolios:manage"

    # ç³»ç»Ÿç®¡ç†æƒé™
    SYSTEM_ADMIN = "system:admin"
    AUDIT_LOGS = "system:audit"

class Role(Enum):
    ADMIN = "admin"
    PREMIUM_USER = "premium_user"
    BASIC_USER = "basic_user"
    GUEST = "guest"

@dataclass
class User:
    id: int
    username: str
    email: str
    roles: Set[Role]
    permissions: Set[Permission]

class RBACManager:
    def __init__(self):
        self.role_permissions = self._initialize_role_permissions()
        self.user_permissions_cache = {}

    def _initialize_role_permissions(self) -> Dict[Role, Set[Permission]]:
        """åˆå§‹åŒ–è§’è‰²æƒé™æ˜ å°„"""
        return {
            Role.GUEST: {
                Permission.READ_FUNDS,
            },

            Role.BASIC_USER: {
                Permission.READ_FUNDS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.USE_BASIC_ANALYSIS,
            },

            Role.PREMIUM_USER: {
                Permission.READ_FUNDS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.USE_BASIC_ANALYSIS,
                Permission.USE_ADVANCED_ANALYSIS,
                Permission.ANALYZE_FUNDS,
            },

            Role.ADMIN: {
                # åŒ…å«æ‰€æœ‰æƒé™
                Permission.READ_USERS,
                Permission.WRITE_USERS,
                Permission.DELETE_USERS,
                Permission.READ_FUNDS,
                Permission.WRITE_FUNDS,
                Permission.ANALYZE_FUNDS,
                Permission.USE_BASIC_ANALYSIS,
                Permission.USE_ADVANCED_ANALYSIS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.SYSTEM_ADMIN,
                Permission.AUDIT_LOGS,
            },
        }

    def get_user_permissions(self, user: User) -> Set[Permission]:
        """è·å–ç”¨æˆ·æƒé™"""
        # æ£€æŸ¥ç¼“å­˜
        if user.id in self.user_permissions_cache:
            return self.user_permissions_cache[user.id]

        permissions = set()

        # æ”¶é›†æ‰€æœ‰è§’è‰²çš„æƒé™
        for role in user.roles:
            permissions.update(self.role_permissions.get(role, set()))

        # æ·»åŠ ç”¨æˆ·ç‰¹å®šçš„æƒé™
        permissions.update(user.permissions)

        # ç¼“å­˜ç»“æœ
        self.user_permissions_cache[user.id] = permissions

        return permissions

    def has_permission(self, user: User, permission: Permission) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ç‰¹å®šæƒé™"""
        user_permissions = self.get_user_permissions(user)
        return permission in user_permissions

    def has_any_permission(self, user: User, permissions: List[Permission]) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ä»»ä¸€æƒé™"""
        user_permissions = self.get_user_permissions(user)
        return any(perm in user_permissions for perm in permissions)

    def has_all_permissions(self, user: User, permissions: List[Permission]) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰æ‰€æœ‰æƒé™"""
        user_permissions = self.get_user_permissions(user)
        return all(perm in user_permissions for perm in permissions)

    def add_role_to_user(self, user: User, role: Role) -> bool:
        """ä¸ºç”¨æˆ·æ·»åŠ è§’è‰²"""
        if role not in user.roles:
            user.roles.add(role)
            # æ¸…é™¤ç¼“å­˜
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

    def remove_role_from_user(self, user: User, role: Role) -> bool:
        """ä»ç”¨æˆ·ç§»é™¤è§’è‰²"""
        if role in user.roles:
            user.roles.remove(role)
            # æ¸…é™¤ç¼“å­˜
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

    def add_permission_to_user(self, user: User, permission: Permission) -> bool:
        """ä¸ºç”¨æˆ·æ·»åŠ ç‰¹å®šæƒé™"""
        if permission not in user.permissions:
            user.permissions.add(permission)
            # æ¸…é™¤ç¼“å­˜
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

# FastAPIé›†æˆ
rbac_manager = RBACManager()

def require_permission(permission: Permission):
    """æƒé™æ£€æŸ¥è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not rbac_manager.has_permission(current_user, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission {permission.value} required"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def require_role(role: Role):
    """è§’è‰²æ£€æŸ¥è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if role not in current_user.roles:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Role {role.value} required"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# è·¯ç”±ä¿æŠ¤ç¤ºä¾‹
@app.get("/admin/users")
@require_role(Role.ADMIN)
async def get_users(current_user: User = Depends(get_current_user)):
    """ç®¡ç†å‘˜è·å–ç”¨æˆ·åˆ—è¡¨"""
    pass

@app.post("/portfolios")
@require_permission(Permission.CREATE_PORTFOLIOS)
async def create_portfolio(
    portfolio_data: PortfolioCreate,
    current_user: User = Depends(get_current_user)
):
    """åˆ›å»ºæŠ•èµ„ç»„åˆ"""
    pass
```

### 5.5 å®‰å…¨ç›‘æ§ä¸å®¡è®¡

#### 5.5.1 å®‰å…¨äº‹ä»¶ç›‘æ§

**å®‰å…¨ç›‘æ§æ¶æ„**ï¼š
```python
# security/monitoring.py - å®‰å…¨ç›‘æ§
from datetime import datetime, timedelta
from typing import List, Dict, Any
import asyncio
from dataclasses import dataclass
from enum import Enum
import logging

class SecurityEventType(Enum):
    LOGIN_SUCCESS = "login_success"
    LOGIN_FAILURE = "login_failure"
    MFA_FAILURE = "mfa_failure"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    DATA_ACCESS = "data_access"
    DATA_MODIFICATION = "data_modification"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"
    SECURITY_BREACH = "security_breach"

@dataclass
class SecurityEvent:
    event_type: SecurityEventType
    user_id: Optional[int]
    ip_address: str
    user_agent: str
    timestamp: datetime
    details: Dict[str, Any]
    severity: str  # low, medium, high, critical

class SecurityMonitor:
    def __init__(self):
        self.event_handlers = {
            SecurityEventType.LOGIN_FAILURE: self._handle_login_failure,
            SecurityEventType.SUSPICIOUS_ACTIVITY: self._handle_suspicious_activity,
            SecurityEventType.SECURITY_BREACH: self._handle_security_breach,
        }

        self.alert_thresholds = {
            SecurityEventType.LOGIN_FAILURE: 5,  # 5æ¬¡å¤±è´¥åå‘Šè­¦
            SecurityEventType.UNAUTHORIZED_ACCESS: 3,  # 3æ¬¡æœªæˆæƒè®¿é—®åå‘Šè­¦
        }

    async def log_security_event(self, event: SecurityEvent):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        # è®°å½•åˆ°æ•°æ®åº“
        await self._save_security_event(event)

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘å‘Šè­¦
        await self._check_alert_conditions(event)

        # è°ƒç”¨äº‹ä»¶å¤„ç†å™¨
        handler = self.event_handlers.get(event.event_type)
        if handler:
            await handler(event)

        # è®°å½•æ—¥å¿—
        logger.info(f"Security event: {event.event_type.value} from {event.ip_address}")

    async def _save_security_event(self, event: SecurityEvent):
        """ä¿å­˜å®‰å…¨äº‹ä»¶åˆ°æ•°æ®åº“"""
        # å®ç°æ•°æ®åº“ä¿å­˜é€»è¾‘
        pass

    async def _check_alert_conditions(self, event: SecurityEvent):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        # æ£€æŸ¥é¢‘ç‡å‘Šè­¦
        recent_events = await self._get_recent_events(
            event.event_type,
            event.ip_address,
            timedelta(minutes=5)
        )

        threshold = self.alert_thresholds.get(event.event_type, 10)
        if len(recent_events) >= threshold:
            await self._send_alert(
                f"High frequency {event.event_type.value} events detected",
                event.severity
            )

    async def _get_recent_events(
        self,
        event_type: SecurityEventType,
        ip_address: str,
        time_window: timedelta
    ) -> List[SecurityEvent]:
        """è·å–æœ€è¿‘çš„å®‰å…¨äº‹ä»¶"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        return []

    async def _send_alert(self, message: str, severity: str):
        """å‘é€å®‰å…¨å‘Šè­¦"""
        # å‘é€é‚®ä»¶å‘Šè­¦
        await self._send_email_alert(message, severity)

        # å‘é€çŸ­ä¿¡å‘Šè­¦ï¼ˆé’ˆå¯¹é«˜å±äº‹ä»¶ï¼‰
        if severity in ["high", "critical"]:
            await self._send_sms_alert(message)

    async def _send_email_alert(self, message: str, severity: str):
        """å‘é€é‚®ä»¶å‘Šè­¦"""
        # å®ç°é‚®ä»¶å‘é€é€»è¾‘
        pass

    async def _send_sms_alert(self, message: str):
        """å‘é€çŸ­ä¿¡å‘Šè­¦"""
        # å®ç°çŸ­ä¿¡å‘é€é€»è¾‘
        pass

    # äº‹ä»¶å¤„ç†å™¨
    async def _handle_login_failure(self, event: SecurityEvent):
        """å¤„ç†ç™»å½•å¤±è´¥äº‹ä»¶"""
        # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸´æ—¶å°ç¦IP
        recent_failures = await self._get_recent_events(
            SecurityEventType.LOGIN_FAILURE,
            event.ip_address,
            timedelta(minutes=15)
        )

        if len(recent_failures) >= 10:
            # ä¸´æ—¶å°ç¦IP 30åˆ†é’Ÿ
            await self._temporary_block_ip(event.ip_address, timedelta(minutes=30))

    async def _handle_suspicious_activity(self, event: SecurityEvent):
        """å¤„ç†å¯ç–‘æ´»åŠ¨äº‹ä»¶"""
        # è§¦å‘é¢å¤–éªŒè¯
        await self._require_additional_verification(event.user_id)

    async def _handle_security_breach(self, event: SecurityEvent):
        """å¤„ç†å®‰å…¨æ¼æ´äº‹ä»¶"""
        # ç«‹å³å‘é€é«˜å±å‘Šè­¦
        await self._send_critical_alert(event)

        # å¯èƒ½éœ€è¦æš‚åœç”¨æˆ·è´¦æˆ·
        if event.user_id:
            await self._suspend_user_account(event.user_id)

    async def _temporary_block_ip(self, ip_address: str, duration: timedelta):
        """ä¸´æ—¶å°ç¦IP"""
        # å®ç°IPå°ç¦é€»è¾‘
        logger.warning(f"Temporarily blocking IP: {ip_address} for {duration}")

    async def _require_additional_verification(self, user_id: int):
        """è¦æ±‚é¢å¤–éªŒè¯"""
        # å®ç°é¢å¤–éªŒè¯é€»è¾‘
        pass

    async def _suspend_user_account(self, user_id: int):
        """æš‚åœç”¨æˆ·è´¦æˆ·"""
        # å®ç°è´¦æˆ·æš‚åœé€»è¾‘
        pass

    async def _send_critical_alert(self, event: SecurityEvent):
        """å‘é€ç´§æ€¥å‘Šè­¦"""
        message = f"CRITICAL: {event.event_type.value} detected from {event.ip_address}"
        await self._send_alert(message, "critical")

# FastAPIä¸­é—´ä»¶é›†æˆ
from fastapi import Request, Response
from fastapi.middleware.base import BaseHTTPMiddleware

class SecurityLoggingMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, security_monitor: SecurityMonitor):
        super().__init__(app)
        self.security_monitor = security_monitor

    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # è®°å½•æ•æ„Ÿæ“ä½œ
        if self._is_sensitive_endpoint(request.url.path):
            await self.security_monitor.log_security_event(
                SecurityEvent(
                    event_type=SecurityEventType.DATA_ACCESS,
                    user_id=getattr(request.state, 'user_id', None),
                    ip_address=request.client.host,
                    user_agent=request.headers.get('user-agent', ''),
                    timestamp=datetime.utcnow(),
                    details={
                        'method': request.method,
                        'path': request.url.path,
                        'status_code': response.status_code,
                    },
                    severity='low'
                )
            )

        return response

    def _is_sensitive_endpoint(self, path: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ•æ„Ÿç«¯ç‚¹"""
        sensitive_patterns = [
            '/api/v1/users',
            '/api/v1/portfolios',
            '/api/v1/admin',
        ]
        return any(pattern in path for pattern in sensitive_patterns)
```

### 5.6 åˆè§„æ€§ç®¡ç†

#### 5.6.1 æ•°æ®ä¿æŠ¤åˆè§„

**GDPRå’Œéšç§ä¿æŠ¤å®ç°**ï¼š
```python
# compliance/gdpr_manager.py - GDPRåˆè§„ç®¡ç†
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json
import hashlib

class GDPRManager:
    def __init__(self):
        self.retention_policies = {
            'user_data': timedelta(days=2555),  # 7å¹´
            'financial_data': timedelta(days=2555),  # 7å¹´
            'access_logs': timedelta(days=365),  # 1å¹´
            'analytics_data': timedelta(days=730),  # 2å¹´
        }

    async def export_user_data(self, user_id: int) -> Dict[str, Any]:
        """å¯¼å‡ºç”¨æˆ·æ•°æ®ï¼ˆGDPRç¬¬20æ¡ - æ•°æ®å¯æºå¸¦æƒï¼‰"""
        user_data = {
            'personal_info': await self._get_user_personal_info(user_id),
            'financial_data': await self._get_user_financial_data(user_id),
            'portfolio_data': await self._get_user_portfolio_data(user_id),
            'activity_logs': await self._get_user_activity_logs(user_id),
            'preferences': await self._get_user_preferences(user_id),
            'export_timestamp': datetime.utcnow().isoformat(),
            'export_format': 'JSON'
        }

        # è®°å½•æ•°æ®å¯¼å‡ºäº‹ä»¶
        await self._log_data_export(user_id, 'user_requested')

        return user_data

    async def delete_user_data(self, user_id: int, reason: str) -> bool:
        """åˆ é™¤ç”¨æˆ·æ•°æ®ï¼ˆGDPRç¬¬17æ¡ - è¢«é—å¿˜æƒï¼‰"""
        try:
            # åŒ¿ååŒ–è€Œéåˆ é™¤ï¼Œä»¥ä¿æŒæ•°æ®å®Œæ•´æ€§
            await self._anonymize_user_data(user_id)

            # è®°å½•åˆ é™¤äº‹ä»¶
            await self._log_data_deletion(user_id, reason)

            # åˆ é™¤å¯åˆ é™¤çš„æ•°æ®
            await self._delete_deletable_data(user_id)

            return True

        except Exception as e:
            logger.error(f"Failed to delete user data for user {user_id}: {e}")
            return False

    async def rectify_user_data(self, user_id: int, corrections: Dict[str, Any]) -> bool:
        """ä¿®æ­£ç”¨æˆ·æ•°æ®ï¼ˆGDPRç¬¬16æ¡ - æ•°æ®æ›´æ­£æƒï¼‰"""
        try:
            # éªŒè¯ä¿®æ­£æ•°æ®çš„æœ‰æ•ˆæ€§
            if await self._validate_corrections(corrections):
                # åº”ç”¨ä¿®æ­£
                await self._apply_data_corrections(user_id, corrections)

                # è®°å½•ä¿®æ­£äº‹ä»¶
                await self._log_data_rectification(user_id, corrections)

                return True
            else:
                return False

        except Exception as e:
            logger.error(f"Failed to rectify user data for user {user_id}: {e}")
            return False

    async def get_data_processing_activities(self) -> Dict[str, Any]:
        """è·å–æ•°æ®å¤„ç†æ´»åŠ¨ï¼ˆGDPRç¬¬30æ¡ï¼‰"""
        return {
            'data_controller': {
                'name': 'åŸºé€ŸåŸºé‡‘é‡åŒ–åˆ†æå¹³å°',
                'contact': 'privacy@jisu.com',
                'dpo_contact': 'dpo@jisu.com'
            },
            'processing_activities': [
                {
                    'purpose': 'åŸºé‡‘æ•°æ®åˆ†æå’ŒæŠ•èµ„ç»„åˆç®¡ç†',
                    'legal_basis': 'legitimate_interest',
                    'data_categories': ['personal_data', 'financial_data'],
                    'retention_period': '7å¹´',
                    'recipients': ['internal_teams', 'regulatory_authorities'],
                    'international_transfers': False
                }
            ],
            'security_measures': await self._get_security_measures(),
            'data_subject_rights': [
                'access', 'rectification', 'erasure', 'portability',
                'objection', 'restriction_of_processing'
            ]
        }

    async def _get_user_personal_info(self, user_id: int) -> Dict[str, Any]:
        """è·å–ç”¨æˆ·ä¸ªäººä¿¡æ¯"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        pass

    async def _get_user_financial_data(self, user_id: int) -> List[Dict[str, Any]]:
        """è·å–ç”¨æˆ·é‡‘èæ•°æ®"""
        # å®ç°æ•°æ®åº“æŸ¥è¯¢é€»è¾‘
        pass

    async def _anonymize_user_data(self, user_id: int):
        """åŒ¿ååŒ–ç”¨æˆ·æ•°æ®"""
        # ç”¨éšæœºç”Ÿæˆçš„æ ‡è¯†ç¬¦æ›¿æ¢çœŸå®æ ‡è¯†ç¬¦
        anonymized_id = hashlib.sha256(f"user_{user_id}_{datetime.utcnow()}".encode()).hexdigest()[:16]

        # æ›´æ–°ç”¨æˆ·è¡¨
        # æ›´æ–°ç›¸å…³è¡¨çš„å¤–é”®å¼•ç”¨
        pass

    async def _log_data_export(self, user_id: int, request_type: str):
        """è®°å½•æ•°æ®å¯¼å‡ºäº‹ä»¶"""
        # å®ç°å®¡è®¡æ—¥å¿—è®°å½•
        pass

    def generate_data_processing_agreement(self) -> str:
        """ç”Ÿæˆæ•°æ®å¤„ç†åè®®"""
        return """
        æ•°æ®å¤„ç†åè®® (DPA)

        1. æ•°æ®æ§åˆ¶è€…å’Œå¤„ç†è€…çš„èº«ä»½
        2. å¤„ç†çš„ä¸»é¢˜æ•°æ®å’Œç±»åˆ«
        3. å¤„ç†çš„æ€§è´¨å’Œç›®çš„
        4. å¤„ç†çš„æœŸé™
        5. å®‰å…¨ä¹‰åŠ¡
        6. å­å¤„ç†çš„ä½¿ç”¨
        7. æ•°æ®ä¸»ä½“æƒåˆ©çš„ååŠ©
        8. å¤„ç†ç»“æŸåçš„æ•°æ®å¤„ç†
        9. å®‰å…¨å®¡è®¡çš„æƒåˆ©
        10. é€‚ç”¨æ³•å¾‹çš„å˜æ›´
        """

# é‡‘èè¡Œä¸šåˆè§„
class FinancialComplianceManager:
    def __init__(self):
        self.regulatory_requirements = {
            'anti_money_laundering': True,
            'kyc_verification': True,
            'transaction_monitoring': True,
            'reporting_requirements': True
        }

    async def perform_kyc_verification(self, user_id: int, kyc_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡ŒKYCéªŒè¯"""
        verification_result = {
            'status': 'pending',
            'risk_level': 'unknown',
            'verified_at': None,
            'documents_required': [],
            'flags': []
        }

        # éªŒè¯èº«ä»½ä¿¡æ¯
        if await self._verify_identity_documents(kyc_data):
            verification_result['status'] = 'verified'
            verification_result['verified_at'] = datetime.utcnow().isoformat()
        else:
            verification_result['status'] = 'rejected'
            verification_result['documents_required'] = [
                'government_issued_id',
                'proof_of_address',
                'bank_statement'
            ]

        # é£é™©è¯„ä¼°
        verification_result['risk_level'] = await self._assess_user_risk(kyc_data)

        # è®°å½•KYCéªŒè¯
        await self._log_kyc_verification(user_id, verification_result)

        return verification_result

    async def monitor_suspicious_transactions(self, user_id: int) -> List[Dict[str, Any]]:
        """ç›‘æ§å¯ç–‘äº¤æ˜“"""
        suspicious_patterns = [
            'unusually_large_transactions',
            'frequent_small_transactions',
            'rapid_account_changes',
            'international_transfers',
            'high_risk_country_involvement'
        ]

        suspicious_transactions = []

        for pattern in suspicious_patterns:
            transactions = await self._detect_pattern(user_id, pattern)
            if transactions:
                suspicious_transactions.extend(transactions)

        # ç”ŸæˆSARæŠ¥å‘Šï¼ˆå¯ç–‘æ´»åŠ¨æŠ¥å‘Šï¼‰
        if suspicious_transactions:
            await self._generate_sar_report(user_id, suspicious_transactions)

        return suspicious_transactions

    async def _verify_identity_documents(self, kyc_data: Dict[str, Any]) -> bool:
        """éªŒè¯èº«ä»½æ–‡æ¡£"""
        # å®ç°æ–‡æ¡£éªŒè¯é€»è¾‘
        return True

    async def _assess_user_risk(self, kyc_data: Dict[str, Any]) -> str:
        """è¯„ä¼°ç”¨æˆ·é£é™©ç­‰çº§"""
        # å®ç°é£é™©è¯„ä¼°é€»è¾‘
        return 'low'

    async def _detect_pattern(self, user_id: int, pattern: str) -> List[Dict[str, Any]]:
        """æ£€æµ‹å¯ç–‘æ¨¡å¼"""
        # å®ç°æ¨¡å¼æ£€æµ‹é€»è¾‘
        return []

    async def _generate_sar_report(self, user_id: int, transactions: List[Dict[str, Any]]):
        """ç”Ÿæˆå¯ç–‘æ´»åŠ¨æŠ¥å‘Š"""
        # å®ç°SARæŠ¥å‘Šç”Ÿæˆ
        pass
```

---

*æœ¬ç« èŠ‚è¯¦ç»†è¯´æ˜äº†åŸºé€Ÿå¹³å°çš„å®‰å…¨æ¶æ„è®¾è®¡ï¼ŒåŒ…æ‹¬ç½‘ç»œå®‰å…¨ã€æ•°æ®å®‰å…¨ã€èº«ä»½è®¤è¯ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨ç›‘æ§å’Œåˆè§„ç®¡ç†ç­‰å„ä¸ªå±‚é¢çš„å®‰å…¨ä¿éšœæªæ–½ï¼Œç¡®ä¿å¹³å°åœ¨é‡‘èç§‘æŠ€é¢†åŸŸçš„é«˜å®‰å…¨æ€§è¦æ±‚*