# 5. 安全架构

## 🔒 安全架构概述

基速基金量化分析平台作为金融科技应用，安全是架构设计的核心要素。本章节详细阐述平台的安全架构设计，包括数据安全、网络安全、访问控制、合规性管理等各个层面的安全保障措施。

### 5.1 安全架构目标

#### 5.1.1 核心安全目标

**机密性 (Confidentiality)**
- 确保用户数据和金融信息的机密性
- 防止敏感信息泄露给未授权方
- 保护用户隐私和投资决策信息

**完整性 (Integrity)**
- 确保金融数据的完整性和准确性
- 防止数据被未授权修改或破坏
- 保证系统功能的正确性

**可用性 (Availability)**
- 确保系统服务的持续可用性
- 防止服务拒绝攻击影响业务运营
- 保证用户能够正常访问系统功能

**可审计性 (Accountability)**
- 记录所有关键操作和访问行为
- 提供完整的审计追踪能力
- 支持安全事件的调查和分析

#### 5.1.2 安全设计原则

**深度防御 (Defense in Depth)**
```yaml
security_layers:
  - network_layer: 网络层面的安全防护
  - application_layer: 应用程序安全机制
  - data_layer: 数据存储和传输安全
  - infrastructure_layer: 基础设施安全措施
  - physical_layer: 物理环境安全保护
```

**最小权限原则 (Principle of Least Privilege)**
- 用户和系统只获得完成其任务所需的最小权限
- 实施基于角色的访问控制（RBAC）
- 定期审查和调整权限分配

**安全默认 (Secure by Default)**
- 系统默认配置为最安全状态
- 需要明确授权才能降低安全级别
- 所有安全组件默认启用

### 5.2 网络安全架构

#### 5.2.1 网络层次安全

**网络边界安全**
```yaml
network_security:
  # 边界防护
  perimeter_security:
    - web_application_firewall: WAF防护
    - ddos_protection: DDoS攻击防护
    - ssl_termination: SSL卸载和加速
    - network_access_control: 网络访问控制

  # 区域隔离
  zone_separation:
    - dmz_zone: DMZ区域（面向互联网）
    - application_zone: 应用服务区域
    - database_zone: 数据库存储区域
    - management_zone: 管理区域
```

**网络安全实现**：
```python
# security/network_security.py - 网络安全配置
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
import ipaddress
from typing import Set

class NetworkSecurityManager:
    def __init__(self, app: FastAPI):
        self.app = app
        self.trusted_ips: Set[str] = set()
        self.blocked_ips: Set[str] = set()
        self.setup_security_middleware()

    def setup_security_middleware(self):
        """设置安全中间件"""

        # CORS配置
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=self._get_allowed_origins(),
            allow_credentials=True,
            allow_methods=["GET", "POST", "PUT", "DELETE"],
            allow_headers=["*"],
            max_age=3600,
        )

        # 信任主机中间件
        self.app.add_middleware(
            TrustedHostMiddleware,
            allowed_hosts=self._get_allowed_hosts()
        )

        # 安全头中间件
        self.app.middleware("http")(self._add_security_headers)

        # IP黑白名单中间件
        self.app.middleware("http")(self._ip_filter_middleware)

    def _add_security_headers(self, request: Request, call_next):
        """添加安全头"""
        response = call_next(request)

        # 安全头设置
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "font-src 'self' https:; "
            "connect-src 'self' https:; "
            "media-src 'self' https:; "
            "object-src 'none'; "
            "base-uri 'self'; "
            "form-action 'self'; "
            "frame-ancestors 'none'; "
            "upgrade-insecure-requests"
        )

        return response

    async def _ip_filter_middleware(self, request: Request, call_next):
        """IP过滤中间件"""
        client_ip = get_remote_address(request)

        # 检查IP是否在黑名单中
        if client_ip in self.blocked_ips:
            raise HTTPException(status_code=403, detail="IP address blocked")

        # 检查IP是否在白名单中（如果启用了白名单）
        if self.trusted_ips and client_ip not in self.trusted_ips:
            raise HTTPException(status_code=403, detail="IP address not authorized")

        return await call_next(request)

    def _get_allowed_origins(self) -> list:
        """获取允许的域名"""
        return [
            "https://yourdomain.com",
            "https://app.yourdomain.com",
            "http://localhost:3000",  # 开发环境
            "http://localhost:8080",
        ]

    def _get_allowed_hosts(self) -> list:
        """获取允许的主机"""
        return [
            "yourdomain.com",
            "app.yourdomain.com",
            "localhost",
            "127.0.0.1",
        ]

    def add_trusted_ip(self, ip: str):
        """添加信任IP"""
        try:
            # 验证IP地址格式
            ipaddress.ip_address(ip)
            self.trusted_ips.add(ip)
            logger.info(f"Added trusted IP: {ip}")
        except ValueError:
            raise ValueError(f"Invalid IP address: {ip}")

    def block_ip(self, ip: str):
        """封禁IP"""
        try:
            ipaddress.ip_address(ip)
            self.blocked_ips.add(ip)
            logger.warning(f"Blocked IP: {ip}")
        except ValueError:
            raise ValueError(f"Invalid IP address: {ip}")
```

#### 5.2.2 API安全防护

**API安全策略**：
```python
# security/api_security.py - API安全
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional
import hashlib
import secrets

class APISecurityManager:
    def __init__(self):
        self.security = HTTPBearer()
        self.secret_key = secrets.token_urlsafe(32)
        self.algorithm = "HS256"
        self.access_token_expire_minutes = 30
        self.refresh_token_expire_days = 7

    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):
        """创建访问令牌"""
        to_encode = data.copy()

        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)

        to_encode.update({"exp": expire, "type": "access"})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    def create_refresh_token(self, data: dict):
        """创建刷新令牌"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(days=self.refresh_token_expire_days)
        to_encode.update({"exp": expire, "type": "refresh"})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt

    async def verify_token(self, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer())):
        """验证令牌"""
        credentials_exception = HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

        try:
            payload = jwt.decode(credentials.credentials, self.secret_key, algorithms=[self.algorithm])
            username: str = payload.get("sub")
            token_type: str = payload.get("type")

            if username is None or token_type != "access":
                raise credentials_exception

        except JWTError:
            raise credentials_exception

        return username

    def hash_password(self, password: str) -> str:
        """密码哈希"""
        salt = secrets.token_hex(16)
        pwdhash = hashlib.pbkdf2_hmac('sha256',
                                      password.encode('utf-8'),
                                      salt.encode('utf-8'),
                                      100000)
        return salt + pwdhash.hex()

    def verify_password(self, stored_password: str, provided_password: str) -> bool:
        """验证密码"""
        salt = stored_password[:32]
        stored_hash = stored_password[32:]
        pwdhash = hashlib.pbkdf2_hmac('sha256',
                                      provided_password.encode('utf-8'),
                                      salt.encode('utf-8'),
                                      100000)
        return pwdhash.hex() == stored_hash

# 依赖注入使用示例
security_manager = APISecurityManager()

async def get_current_user(token: str = Depends(security_manager.verify_token)):
    """获取当前用户"""
    # 这里可以从数据库获取用户信息
    return {"username": token}

# 路由保护示例
@app.get("/protected-route")
async def protected_route(current_user: dict = Depends(get_current_user)):
    """需要认证的路由"""
    return {"message": f"Hello {current_user['username']}"}
```

### 5.3 数据安全架构

#### 5.3.1 数据加密策略

**数据分类和加密要求**：
```yaml
data_classification:
  # 高敏感数据
  highly_sensitive:
    - user_passwords: "AES-256 + PBKDF2"
    - financial_data: "AES-256"
    - personal_identification: "AES-256"
    - api_keys: "AES-256"
    encryption_at_rest: True
    encryption_in_transit: True

  # 中等敏感数据
  medium_sensitive:
    - user_preferences: "AES-128"
    - app_usage_data: "AES-128"
    - analytics_data: "AES-128"
    encryption_at_rest: True
    encryption_in_transit: True

  # 低敏感数据
  low_sensitive:
    - public_fund_data: "无加密"
    - general_app_data: "无加密"
    - cached_public_data: "无加密"
    encryption_at_rest: False
    encryption_in_transit: True
```

**加密实现**：
```python
# security/encryption.py - 数据加密管理
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
import json
from typing import Any, Dict, Optional

class EncryptionManager:
    def __init__(self, master_key: Optional[str] = None):
        if master_key:
            self.master_key = master_key.encode()
        else:
            self.master_key = os.environ.get('ENCRYPTION_MASTER_KEY', '').encode()

        if not self.master_key:
            raise ValueError("Encryption master key is required")

        self.fernet = self._create_fernet()

    def _create_fernet(self) -> Fernet:
        """创建Fernet加密器"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'jisu_platform_salt',  # 在生产环境中使用随机salt
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        return Fernet(key)

    def encrypt_data(self, data: Any) -> str:
        """加密数据"""
        if isinstance(data, (dict, list)):
            data_str = json.dumps(data, default=str)
        else:
            data_str = str(data)

        encrypted_data = self.fernet.encrypt(data_str.encode())
        return base64.urlsafe_b64encode(encrypted_data).decode()

    def decrypt_data(self, encrypted_data: str) -> Any:
        """解密数据"""
        try:
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode())
            decrypted_data = self.fernet.decrypt(encrypted_bytes).decode()

            # 尝试解析为JSON
            try:
                return json.loads(decrypted_data)
            except json.JSONDecodeError:
                return decrypted_data

        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise ValueError("Failed to decrypt data")

    def encrypt_sensitive_field(self, value: str, field_type: str) -> Dict[str, str]:
        """加密敏感字段"""
        encrypted_value = self.encrypt_data(value)
        return {
            "encrypted": encrypted_value,
            "field_type": field_type,
            "encryption_version": "v1"
        }

    def decrypt_sensitive_field(self, field_data: Dict[str, str]) -> str:
        """解密敏感字段"""
        if not field_data.get("encrypted"):
            return ""

        try:
            return self.decrypt_data(field_data["encrypted"])
        except Exception:
            logger.error(f"Failed to decrypt field of type: {field_data.get('field_type')}")
            return ""

# 数据库字段加密装饰器
from functools import wraps
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import JSONB

class EncryptedField(sa.TypeDecorator):
    """SQLAlchemy加密字段类型"""
    impl = sa.Text
    cache_ok = True

    def __init__(self, encryption_manager: EncryptionManager, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_manager = encryption_manager

    def process_bind_param(self, value, dialect):
        if value is None:
            return None
        return self.encryption_manager.encrypt_data(value)

    def process_result_value(self, value, dialect):
        if value is None:
            return None
        return self.encryption_manager.decrypt_data(value)

# 数据库模型使用示例
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()
encryption_manager = EncryptionManager()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(EncryptedField(encryption_manager), nullable=False)
    phone = Column(EncryptedField(encryption_manager))
    financial_data = Column(EncryptedField(encryption_manager))
```

#### 5.3.2 数据传输安全

**HTTPS配置和证书管理**：
```python
# security/ssl_manager.py - SSL/TLS管理
import ssl
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import socket
import subprocess
from datetime import datetime, timedelta

class SSLManager:
    def __init__(self):
        self.cert_path = "/etc/ssl/certs/jisu.crt"
        self.key_path = "/etc/ssl/private/jisu.key"
        self.ca_path = "/etc/ssl/certs/ca-bundle.crt"

    def create_ssl_context(self) -> ssl.SSLContext:
        """创建SSL上下文"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

        # 强制使用TLS 1.2或更高版本
        context.minimum_version = ssl.TLSVersion.TLSv1_2

        # 设置加密套件
        context.set_ciphers(
            'ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS'
        )

        # 启用证书验证
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True

        # 加载证书和私钥
        try:
            context.load_cert_chain(self.cert_path, self.key_path)
            context.load_verify_locations(self.ca_path)
        except FileNotFoundError as e:
            logger.error(f"SSL certificate not found: {e}")
            raise

        # 设置HTTP/2支持
        try:
            context.set_alpn_protocols(['h2', 'http/1.1'])
        except AttributeError:
            logger.warning("ALPN protocols not supported")

        return context

    def verify_certificate(self, host: str, port: int = 443) -> bool:
        """验证SSL证书"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED

            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert(binary_form=True)
                    x509_cert = x509.load_der_x509_certificate(cert, default_backend())

                    # 检查证书有效期
                    if datetime.utcnow() > x509_cert.not_valid_after:
                        logger.warning(f"Certificate for {host} has expired")
                        return False

                    # 检查证书主题
                    subject = x509_cert.subject
                    common_name = None
                    for attr in subject:
                        if attr.oid == x509.NameOID.COMMON_NAME:
                            common_name = attr.value
                            break

                    if common_name != host:
                        logger.warning(f"Certificate CN ({common_name}) does not match host ({host})")
                        return False

            return True

        except Exception as e:
            logger.error(f"Certificate verification failed for {host}: {e}")
            return False

    def generate_self_signed_cert(self, domains: list, key_size: int = 2048):
        """生成自签名证书（开发环境使用）"""
        from cryptography.hazmat.primitives import hashes
        from cryptography.hazmat.primitives.asymmetric import rsa
        from cryptography.x509.oid import NameOID

        # 生成私钥
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )

        # 创建证书主题
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "Beijing"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "Beijing"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Jisu Platform"),
            x509.NameAttribute(NameOID.COMMON_NAME, domains[0]),
        ])

        # 创建证书
        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=365)
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(domain) for domain in domains
            ])
        ).sign(private_key, hashes.SHA256(), default_backend())

        # 保存证书和私钥
        with open(self.cert_path, "wb") as f:
            f.write(cert.public_bytes(serialization.Encoding.PEM))

        with open(self.key_path, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ))

        logger.info(f"Self-signed certificate generated for domains: {domains}")

# FastAPI SSL配置
from fastapi import FastAPI
import uvicorn

ssl_manager = SSLManager()

app = FastAPI()

if __name__ == "__main__":
    # 生产环境SSL配置
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=443,
        ssl_keyfile=ssl_manager.key_path,
        ssl_certfile=ssl_manager.cert_path,
        ssl_version=ssl.PROTOCOL_TLS,
        ssl_ciphers="ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20",
    )
```

### 5.4 身份认证与授权

#### 5.4.1 多因素认证架构

**MFA实现方案**：
```python
# security/mfa_manager.py - 多因素认证
import pyotp
import qrcode
from io import BytesIO
import base64
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from typing import Optional
import secrets

class MFAManager:
    def __init__(self):
        self.app_name = "基速基金平台"

    def generate_totp_secret(self, username: str) -> str:
        """生成TOTP密钥"""
        return pyotp.random_base32()

    def generate_qr_code(self, username: str, secret: str) -> str:
        """生成QR码"""
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=username,
            issuer_name=self.app_name
        )

        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")

        # 转换为base64
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        img_str = base64.b64encode(buffered.getvalue()).decode()

        return f"data:image/png;base64,{img_str}"

    def verify_totp_token(self, secret: str, token: str) -> bool:
        """验证TOTP令牌"""
        totp = pyotp.TOTP(secret)
        return totp.verify(token, valid_window=1)  # 允许时间窗口前后30秒

    def generate_backup_codes(self, count: int = 10) -> list:
        """生成备用恢复码"""
        return [secrets.token_hex(4).upper() for _ in range(count)]

    def send_sms_code(self, phone_number: str, code: str) -> bool:
        """发送短信验证码"""
        try:
            # 这里集成短信服务提供商API
            # 示例使用阿里云短信服务
            from aliyunsdkcore.client import AcsClient
            from aliyunsdkcore.acs_exception.exceptions import ServerException
            from aliyunsdksms.request.v20170525 import SendSmsRequest

            client = AcsClient(
                'your-access-key-id',
                'your-access-key-secret',
                'cn-hangzhou'
            )

            request = SendSmsRequest()
            request.set_PhoneNumbers(phone_number)
            request.set_SignName("基速平台")
            request.set_TemplateCode("SMS_123456789")
            request.set_TemplateParam(f'{{"code":"{code}"}}')

            response = client.do_action_with_exception(request)
            return response.get('Code') == 'OK'

        except Exception as e:
            logger.error(f"Failed to send SMS: {e}")
            return False

    def send_email_code(self, email: str, code: str) -> bool:
        """发送邮件验证码"""
        try:
            msg = MimeMultipart()
            msg['From'] = 'noreply@jisu.com'
            msg['To'] = email
            msg['Subject'] = '基速平台验证码'

            body = f"""
            您的验证码是：{code}

            该验证码5分钟内有效，请勿泄露给他人。

            基速基金量化分析平台
            """

            msg.attach(MimeText(body, 'plain'))

            # SMTP配置
            server = smtplib.SMTP('smtp.gmail.com', 587)
            server.starttls()
            server.login('your-email@gmail.com', 'your-app-password')
            text = msg.as_string()
            server.sendmail('noreply@jisu.com', email, text)
            server.quit()

            return True

        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False

# 认证服务集成
class AuthenticationService:
    def __init__(self):
        self.mfa_manager = MFAManager()
        self.user_sessions = {}

    async def setup_mfa(self, user_id: int, mfa_type: str) -> dict:
        """设置多因素认证"""
        if mfa_type == "totp":
            secret = self.mfa_manager.generate_totp_secret(f"user_{user_id}")
            qr_code = self.mfa_manager.generate_qr_code(f"user_{user_id}", secret)
            backup_codes = self.mfa_manager.generate_backup_codes()

            # 保存到数据库
            await self._save_mfa_setup(user_id, {
                "type": "totp",
                "secret": secret,
                "backup_codes": backup_codes,
                "verified": False
            })

            return {
                "qr_code": qr_code,
                "backup_codes": backup_codes,
                "setup_instructions": "请使用Google Authenticator扫描QR码"
            }

        elif mfa_type == "sms":
            # 发送验证短信
            user_phone = await self._get_user_phone(user_id)
            code = f"{secrets.randbelow(1000000):06d}"

            if self.mfa_manager.send_sms_code(user_phone, code):
                await self._save_mfa_setup(user_id, {
                    "type": "sms",
                    "phone": user_phone,
                    "verified": False
                })
                return {"message": "验证码已发送到您的手机"}
            else:
                raise Exception("短信发送失败")

        elif mfa_type == "email":
            # 发送验证邮件
            user_email = await self._get_user_email(user_id)
            code = f"{secrets.randbelow(1000000):06d}"

            if self.mfa_manager.send_email_code(user_email, code):
                await self._save_mfa_setup(user_id, {
                    "type": "email",
                    "email": user_email,
                    "verified": False
                })
                return {"message": "验证码已发送到您的邮箱"}
            else:
                raise Exception("邮件发送失败")

    async def verify_mfa(self, user_id: int, code: str) -> bool:
        """验证多因素认证"""
        mfa_setup = await self._get_mfa_setup(user_id)

        if not mfa_setup:
            return False

        if mfa_setup["type"] == "totp":
            return self.mfa_manager.verify_totp_token(mfa_setup["secret"], code)

        elif mfa_setup["type"] in ["sms", "email"]:
            # 验证短信或邮件验证码
            return await self._verify_one_time_code(user_id, code)

        return False

    async def _save_mfa_setup(self, user_id: int, setup_data: dict):
        """保存MFA设置到数据库"""
        # 实现数据库保存逻辑
        pass

    async def _get_mfa_setup(self, user_id: int) -> Optional[dict]:
        """从数据库获取MFA设置"""
        # 实现数据库查询逻辑
        pass

    async def _get_user_phone(self, user_id: int) -> str:
        """获取用户手机号"""
        # 实现数据库查询逻辑
        pass

    async def _get_user_email(self, user_id: int) -> str:
        """获取用户邮箱"""
        # 实现数据库查询逻辑
        pass

    async def _verify_one_time_code(self, user_id: int, code: str) -> bool:
        """验证一次性验证码"""
        # 实现验证码验证逻辑
        pass
```

#### 5.4.2 基于角色的访问控制(RBAC)

**RBAC架构实现**：
```python
# security/rbac.py - 基于角色的访问控制
from enum import Enum
from typing import List, Set, Dict, Optional
from dataclasses import dataclass
from fastapi import HTTPException, status

class Permission(Enum):
    # 用户管理权限
    READ_USERS = "read:users"
    WRITE_USERS = "write:users"
    DELETE_USERS = "delete:users"

    # 基金数据权限
    READ_FUNDS = "funds:read"
    WRITE_FUNDS = "funds:write"
    ANALYZE_FUNDS = "funds:analyze"

    # 分析工具权限
    USE_BASIC_ANALYSIS = "analysis:basic"
    USE_ADVANCED_ANALYSIS = "analysis:advanced"

    # 投资组合权限
    CREATE_PORTFOLIOS = "portfolios:create"
    MANAGE_PORTFOLIOS = "portfolios:manage"

    # 系统管理权限
    SYSTEM_ADMIN = "system:admin"
    AUDIT_LOGS = "system:audit"

class Role(Enum):
    ADMIN = "admin"
    PREMIUM_USER = "premium_user"
    BASIC_USER = "basic_user"
    GUEST = "guest"

@dataclass
class User:
    id: int
    username: str
    email: str
    roles: Set[Role]
    permissions: Set[Permission]

class RBACManager:
    def __init__(self):
        self.role_permissions = self._initialize_role_permissions()
        self.user_permissions_cache = {}

    def _initialize_role_permissions(self) -> Dict[Role, Set[Permission]]:
        """初始化角色权限映射"""
        return {
            Role.GUEST: {
                Permission.READ_FUNDS,
            },

            Role.BASIC_USER: {
                Permission.READ_FUNDS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.USE_BASIC_ANALYSIS,
            },

            Role.PREMIUM_USER: {
                Permission.READ_FUNDS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.USE_BASIC_ANALYSIS,
                Permission.USE_ADVANCED_ANALYSIS,
                Permission.ANALYZE_FUNDS,
            },

            Role.ADMIN: {
                # 包含所有权限
                Permission.READ_USERS,
                Permission.WRITE_USERS,
                Permission.DELETE_USERS,
                Permission.READ_FUNDS,
                Permission.WRITE_FUNDS,
                Permission.ANALYZE_FUNDS,
                Permission.USE_BASIC_ANALYSIS,
                Permission.USE_ADVANCED_ANALYSIS,
                Permission.CREATE_PORTFOLIOS,
                Permission.MANAGE_PORTFOLIOS,
                Permission.SYSTEM_ADMIN,
                Permission.AUDIT_LOGS,
            },
        }

    def get_user_permissions(self, user: User) -> Set[Permission]:
        """获取用户权限"""
        # 检查缓存
        if user.id in self.user_permissions_cache:
            return self.user_permissions_cache[user.id]

        permissions = set()

        # 收集所有角色的权限
        for role in user.roles:
            permissions.update(self.role_permissions.get(role, set()))

        # 添加用户特定的权限
        permissions.update(user.permissions)

        # 缓存结果
        self.user_permissions_cache[user.id] = permissions

        return permissions

    def has_permission(self, user: User, permission: Permission) -> bool:
        """检查用户是否具有特定权限"""
        user_permissions = self.get_user_permissions(user)
        return permission in user_permissions

    def has_any_permission(self, user: User, permissions: List[Permission]) -> bool:
        """检查用户是否具有任一权限"""
        user_permissions = self.get_user_permissions(user)
        return any(perm in user_permissions for perm in permissions)

    def has_all_permissions(self, user: User, permissions: List[Permission]) -> bool:
        """检查用户是否具有所有权限"""
        user_permissions = self.get_user_permissions(user)
        return all(perm in user_permissions for perm in permissions)

    def add_role_to_user(self, user: User, role: Role) -> bool:
        """为用户添加角色"""
        if role not in user.roles:
            user.roles.add(role)
            # 清除缓存
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

    def remove_role_from_user(self, user: User, role: Role) -> bool:
        """从用户移除角色"""
        if role in user.roles:
            user.roles.remove(role)
            # 清除缓存
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

    def add_permission_to_user(self, user: User, permission: Permission) -> bool:
        """为用户添加特定权限"""
        if permission not in user.permissions:
            user.permissions.add(permission)
            # 清除缓存
            self.user_permissions_cache.pop(user.id, None)
            return True
        return False

# FastAPI集成
rbac_manager = RBACManager()

def require_permission(permission: Permission):
    """权限检查装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not rbac_manager.has_permission(current_user, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission {permission.value} required"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def require_role(role: Role):
    """角色检查装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if role not in current_user.roles:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Role {role.value} required"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# 路由保护示例
@app.get("/admin/users")
@require_role(Role.ADMIN)
async def get_users(current_user: User = Depends(get_current_user)):
    """管理员获取用户列表"""
    pass

@app.post("/portfolios")
@require_permission(Permission.CREATE_PORTFOLIOS)
async def create_portfolio(
    portfolio_data: PortfolioCreate,
    current_user: User = Depends(get_current_user)
):
    """创建投资组合"""
    pass
```

### 5.5 安全监控与审计

#### 5.5.1 安全事件监控

**安全监控架构**：
```python
# security/monitoring.py - 安全监控
from datetime import datetime, timedelta
from typing import List, Dict, Any
import asyncio
from dataclasses import dataclass
from enum import Enum
import logging

class SecurityEventType(Enum):
    LOGIN_SUCCESS = "login_success"
    LOGIN_FAILURE = "login_failure"
    MFA_FAILURE = "mfa_failure"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    DATA_ACCESS = "data_access"
    DATA_MODIFICATION = "data_modification"
    SUSPICIOUS_ACTIVITY = "suspicious_activity"
    SECURITY_BREACH = "security_breach"

@dataclass
class SecurityEvent:
    event_type: SecurityEventType
    user_id: Optional[int]
    ip_address: str
    user_agent: str
    timestamp: datetime
    details: Dict[str, Any]
    severity: str  # low, medium, high, critical

class SecurityMonitor:
    def __init__(self):
        self.event_handlers = {
            SecurityEventType.LOGIN_FAILURE: self._handle_login_failure,
            SecurityEventType.SUSPICIOUS_ACTIVITY: self._handle_suspicious_activity,
            SecurityEventType.SECURITY_BREACH: self._handle_security_breach,
        }

        self.alert_thresholds = {
            SecurityEventType.LOGIN_FAILURE: 5,  # 5次失败后告警
            SecurityEventType.UNAUTHORIZED_ACCESS: 3,  # 3次未授权访问后告警
        }

    async def log_security_event(self, event: SecurityEvent):
        """记录安全事件"""
        # 记录到数据库
        await self._save_security_event(event)

        # 检查是否需要触发告警
        await self._check_alert_conditions(event)

        # 调用事件处理器
        handler = self.event_handlers.get(event.event_type)
        if handler:
            await handler(event)

        # 记录日志
        logger.info(f"Security event: {event.event_type.value} from {event.ip_address}")

    async def _save_security_event(self, event: SecurityEvent):
        """保存安全事件到数据库"""
        # 实现数据库保存逻辑
        pass

    async def _check_alert_conditions(self, event: SecurityEvent):
        """检查告警条件"""
        # 检查频率告警
        recent_events = await self._get_recent_events(
            event.event_type,
            event.ip_address,
            timedelta(minutes=5)
        )

        threshold = self.alert_thresholds.get(event.event_type, 10)
        if len(recent_events) >= threshold:
            await self._send_alert(
                f"High frequency {event.event_type.value} events detected",
                event.severity
            )

    async def _get_recent_events(
        self,
        event_type: SecurityEventType,
        ip_address: str,
        time_window: timedelta
    ) -> List[SecurityEvent]:
        """获取最近的安全事件"""
        # 实现数据库查询逻辑
        return []

    async def _send_alert(self, message: str, severity: str):
        """发送安全告警"""
        # 发送邮件告警
        await self._send_email_alert(message, severity)

        # 发送短信告警（针对高危事件）
        if severity in ["high", "critical"]:
            await self._send_sms_alert(message)

    async def _send_email_alert(self, message: str, severity: str):
        """发送邮件告警"""
        # 实现邮件发送逻辑
        pass

    async def _send_sms_alert(self, message: str):
        """发送短信告警"""
        # 实现短信发送逻辑
        pass

    # 事件处理器
    async def _handle_login_failure(self, event: SecurityEvent):
        """处理登录失败事件"""
        # 检查是否需要临时封禁IP
        recent_failures = await self._get_recent_events(
            SecurityEventType.LOGIN_FAILURE,
            event.ip_address,
            timedelta(minutes=15)
        )

        if len(recent_failures) >= 10:
            # 临时封禁IP 30分钟
            await self._temporary_block_ip(event.ip_address, timedelta(minutes=30))

    async def _handle_suspicious_activity(self, event: SecurityEvent):
        """处理可疑活动事件"""
        # 触发额外验证
        await self._require_additional_verification(event.user_id)

    async def _handle_security_breach(self, event: SecurityEvent):
        """处理安全漏洞事件"""
        # 立即发送高危告警
        await self._send_critical_alert(event)

        # 可能需要暂停用户账户
        if event.user_id:
            await self._suspend_user_account(event.user_id)

    async def _temporary_block_ip(self, ip_address: str, duration: timedelta):
        """临时封禁IP"""
        # 实现IP封禁逻辑
        logger.warning(f"Temporarily blocking IP: {ip_address} for {duration}")

    async def _require_additional_verification(self, user_id: int):
        """要求额外验证"""
        # 实现额外验证逻辑
        pass

    async def _suspend_user_account(self, user_id: int):
        """暂停用户账户"""
        # 实现账户暂停逻辑
        pass

    async def _send_critical_alert(self, event: SecurityEvent):
        """发送紧急告警"""
        message = f"CRITICAL: {event.event_type.value} detected from {event.ip_address}"
        await self._send_alert(message, "critical")

# FastAPI中间件集成
from fastapi import Request, Response
from fastapi.middleware.base import BaseHTTPMiddleware

class SecurityLoggingMiddleware(BaseHTTPMiddleware):
    def __init__(self, app, security_monitor: SecurityMonitor):
        super().__init__(app)
        self.security_monitor = security_monitor

    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # 记录敏感操作
        if self._is_sensitive_endpoint(request.url.path):
            await self.security_monitor.log_security_event(
                SecurityEvent(
                    event_type=SecurityEventType.DATA_ACCESS,
                    user_id=getattr(request.state, 'user_id', None),
                    ip_address=request.client.host,
                    user_agent=request.headers.get('user-agent', ''),
                    timestamp=datetime.utcnow(),
                    details={
                        'method': request.method,
                        'path': request.url.path,
                        'status_code': response.status_code,
                    },
                    severity='low'
                )
            )

        return response

    def _is_sensitive_endpoint(self, path: str) -> bool:
        """判断是否为敏感端点"""
        sensitive_patterns = [
            '/api/v1/users',
            '/api/v1/portfolios',
            '/api/v1/admin',
        ]
        return any(pattern in path for pattern in sensitive_patterns)
```

### 5.6 合规性管理

#### 5.6.1 数据保护合规

**GDPR和隐私保护实现**：
```python
# compliance/gdpr_manager.py - GDPR合规管理
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json
import hashlib

class GDPRManager:
    def __init__(self):
        self.retention_policies = {
            'user_data': timedelta(days=2555),  # 7年
            'financial_data': timedelta(days=2555),  # 7年
            'access_logs': timedelta(days=365),  # 1年
            'analytics_data': timedelta(days=730),  # 2年
        }

    async def export_user_data(self, user_id: int) -> Dict[str, Any]:
        """导出用户数据（GDPR第20条 - 数据可携带权）"""
        user_data = {
            'personal_info': await self._get_user_personal_info(user_id),
            'financial_data': await self._get_user_financial_data(user_id),
            'portfolio_data': await self._get_user_portfolio_data(user_id),
            'activity_logs': await self._get_user_activity_logs(user_id),
            'preferences': await self._get_user_preferences(user_id),
            'export_timestamp': datetime.utcnow().isoformat(),
            'export_format': 'JSON'
        }

        # 记录数据导出事件
        await self._log_data_export(user_id, 'user_requested')

        return user_data

    async def delete_user_data(self, user_id: int, reason: str) -> bool:
        """删除用户数据（GDPR第17条 - 被遗忘权）"""
        try:
            # 匿名化而非删除，以保持数据完整性
            await self._anonymize_user_data(user_id)

            # 记录删除事件
            await self._log_data_deletion(user_id, reason)

            # 删除可删除的数据
            await self._delete_deletable_data(user_id)

            return True

        except Exception as e:
            logger.error(f"Failed to delete user data for user {user_id}: {e}")
            return False

    async def rectify_user_data(self, user_id: int, corrections: Dict[str, Any]) -> bool:
        """修正用户数据（GDPR第16条 - 数据更正权）"""
        try:
            # 验证修正数据的有效性
            if await self._validate_corrections(corrections):
                # 应用修正
                await self._apply_data_corrections(user_id, corrections)

                # 记录修正事件
                await self._log_data_rectification(user_id, corrections)

                return True
            else:
                return False

        except Exception as e:
            logger.error(f"Failed to rectify user data for user {user_id}: {e}")
            return False

    async def get_data_processing_activities(self) -> Dict[str, Any]:
        """获取数据处理活动（GDPR第30条）"""
        return {
            'data_controller': {
                'name': '基速基金量化分析平台',
                'contact': 'privacy@jisu.com',
                'dpo_contact': 'dpo@jisu.com'
            },
            'processing_activities': [
                {
                    'purpose': '基金数据分析和投资组合管理',
                    'legal_basis': 'legitimate_interest',
                    'data_categories': ['personal_data', 'financial_data'],
                    'retention_period': '7年',
                    'recipients': ['internal_teams', 'regulatory_authorities'],
                    'international_transfers': False
                }
            ],
            'security_measures': await self._get_security_measures(),
            'data_subject_rights': [
                'access', 'rectification', 'erasure', 'portability',
                'objection', 'restriction_of_processing'
            ]
        }

    async def _get_user_personal_info(self, user_id: int) -> Dict[str, Any]:
        """获取用户个人信息"""
        # 实现数据库查询逻辑
        pass

    async def _get_user_financial_data(self, user_id: int) -> List[Dict[str, Any]]:
        """获取用户金融数据"""
        # 实现数据库查询逻辑
        pass

    async def _anonymize_user_data(self, user_id: int):
        """匿名化用户数据"""
        # 用随机生成的标识符替换真实标识符
        anonymized_id = hashlib.sha256(f"user_{user_id}_{datetime.utcnow()}".encode()).hexdigest()[:16]

        # 更新用户表
        # 更新相关表的外键引用
        pass

    async def _log_data_export(self, user_id: int, request_type: str):
        """记录数据导出事件"""
        # 实现审计日志记录
        pass

    def generate_data_processing_agreement(self) -> str:
        """生成数据处理协议"""
        return """
        数据处理协议 (DPA)

        1. 数据控制者和处理者的身份
        2. 处理的主题数据和类别
        3. 处理的性质和目的
        4. 处理的期限
        5. 安全义务
        6. 子处理的使用
        7. 数据主体权利的协助
        8. 处理结束后的数据处理
        9. 安全审计的权利
        10. 适用法律的变更
        """

# 金融行业合规
class FinancialComplianceManager:
    def __init__(self):
        self.regulatory_requirements = {
            'anti_money_laundering': True,
            'kyc_verification': True,
            'transaction_monitoring': True,
            'reporting_requirements': True
        }

    async def perform_kyc_verification(self, user_id: int, kyc_data: Dict[str, Any]) -> Dict[str, Any]:
        """执行KYC验证"""
        verification_result = {
            'status': 'pending',
            'risk_level': 'unknown',
            'verified_at': None,
            'documents_required': [],
            'flags': []
        }

        # 验证身份信息
        if await self._verify_identity_documents(kyc_data):
            verification_result['status'] = 'verified'
            verification_result['verified_at'] = datetime.utcnow().isoformat()
        else:
            verification_result['status'] = 'rejected'
            verification_result['documents_required'] = [
                'government_issued_id',
                'proof_of_address',
                'bank_statement'
            ]

        # 风险评估
        verification_result['risk_level'] = await self._assess_user_risk(kyc_data)

        # 记录KYC验证
        await self._log_kyc_verification(user_id, verification_result)

        return verification_result

    async def monitor_suspicious_transactions(self, user_id: int) -> List[Dict[str, Any]]:
        """监控可疑交易"""
        suspicious_patterns = [
            'unusually_large_transactions',
            'frequent_small_transactions',
            'rapid_account_changes',
            'international_transfers',
            'high_risk_country_involvement'
        ]

        suspicious_transactions = []

        for pattern in suspicious_patterns:
            transactions = await self._detect_pattern(user_id, pattern)
            if transactions:
                suspicious_transactions.extend(transactions)

        # 生成SAR报告（可疑活动报告）
        if suspicious_transactions:
            await self._generate_sar_report(user_id, suspicious_transactions)

        return suspicious_transactions

    async def _verify_identity_documents(self, kyc_data: Dict[str, Any]) -> bool:
        """验证身份文档"""
        # 实现文档验证逻辑
        return True

    async def _assess_user_risk(self, kyc_data: Dict[str, Any]) -> str:
        """评估用户风险等级"""
        # 实现风险评估逻辑
        return 'low'

    async def _detect_pattern(self, user_id: int, pattern: str) -> List[Dict[str, Any]]:
        """检测可疑模式"""
        # 实现模式检测逻辑
        return []

    async def _generate_sar_report(self, user_id: int, transactions: List[Dict[str, Any]]):
        """生成可疑活动报告"""
        # 实现SAR报告生成
        pass
```

---

*本章节详细说明了基速平台的安全架构设计，包括网络安全、数据安全、身份认证、访问控制、安全监控和合规管理等各个层面的安全保障措施，确保平台在金融科技领域的高安全性要求*