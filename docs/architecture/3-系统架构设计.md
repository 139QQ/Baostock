# 3. 系统架构设计

## 🏗️ 架构设计概述

基速基金量化分析平台采用现代化的分层架构模式，结合微服务理念和事件驱动架构，确保系统的高可用性、可扩展性和可维护性。本章节详细说明系统的整体架构设计和各层组件的设计方案。

### 3.1 整体架构模式

#### 3.1.1 四层架构模式

```
┌─────────────────────────────────────────────────────────────┐
│                    表现层 (Presentation Layer)                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   Web Client    │  │  Mobile Client  │  │ Desktop Client  │ │
│  │  (Flutter Web)  │  │  (Flutter App)  │  │ (Flutter App)   │ │
│  │                 │  │                 │  │                 │ │
│  │ - 路由管理       │  │ - 页面导航       │  │ - 窗口管理       │ │
│  │ - 状态管理       │  │ - 本地存储       │  │ - 文件操作       │ │
│  │ - UI组件        │  │ - 网络请求       │  │ - 系统集成       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                   业务逻辑层 (Business Layer)                 │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   状态管理       │  │   业务服务       │  │   数据处理       │ │
│  │   (BLoC)        │  │ (Services)      │  │ (Utils)         │ │
│  │                 │  │                 │  │                 │ │
│  │ - 状态状态管理    │  │ - 业务逻辑       │  │ - 数据计算       │ │
│  │ - 事件分发       │  │ - 数据验证       │  │ - 格式转换       │ │
│  │ - 数据同步       │  │ - 业务规则       │  │ - 算法实现       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                   数据访问层 (Data Access Layer)              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   网络客户端      │  │   本地缓存       │  │   数据持久化     │ │
│  │   (Dio)         │  │   (Hive)        │  │ (SharedPrefs)   │ │
│  │                 │  │                 │  │                 │ │
│  │ - HTTP请求       │  │ - 内存缓存       │  │ - 用户设置       │ │
│  │ - 错误处理       │  │ - 数据持久化     │  │ - 应用配置       │ │
│  │ - 请求拦截       │  │ - 离线支持       │  │ - 临时数据       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                   基础设施层 (Infrastructure Layer)           │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   API网关        │  │   微服务集群     │  │   数据存储       │ │
│  │ (API Gateway)   │  │ (Microservices)  │  │ (Data Store)    │
│  │                 │  │                 │  │                 │ │
│  │ - 路由分发       │  │ - 基金数据服务   │  │ - PostgreSQL    │ │
│  │ - 认证授权       │  │ - 分析计算服务   │  │ - Redis缓存     │ │
│  │ - 限流控制       │  │ - 用户服务       │  │ - 文件存储       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

#### 3.1.2 微服务架构设计

**服务拆分原则**：
- **业务边界明确**: 按照业务能力拆分服务
- **数据独立性**: 每个服务拥有独立的数据存储
- **单一职责**: 每个服务专注于单一业务领域
- **接口标准化**: 统一的API接口规范

**核心微服务组件**：
```yaml
microservices:
  # 基金数据服务
  fund_data_service:
    description: "基金数据管理核心服务"
    responsibilities:
      - 基金信息查询和管理
      - 基金净值数据获取
      - 数据清洗和验证
    endpoints:
      - GET /api/v1/funds
      - GET /api/v1/funds/{code}
      - GET /api/v1/funds/{code}/nav-history

  # 分析计算服务
  analysis_service:
    description: "量化分析和计算服务"
    responsibilities:
      - 技术指标计算
      - 风险评估算法
      - 收益分析计算
    endpoints:
      - POST /api/v1/analysis/indicators
      - POST /api/v1/analysis/risk-assessment
      - POST /api/v1/analysis/portfolio-analysis

  # 用户服务
  user_service:
    description: "用户管理和个性化服务"
    responsibilities:
      - 用户认证和授权
      - 用户偏好管理
      - 收藏和历史记录
    endpoints:
      - POST /api/v1/auth/login
      - GET /api/v1/users/profile
      - POST /api/v1/users/favorites

  # 通知服务
  notification_service:
    description: "消息推送和通知服务"
    responsibilities:
      - 实时数据推送
      - 价格预警通知
      - 系统消息管理
    endpoints:
      - POST /api/v1/notifications/subscribe
      - POST /api/v1/notifications/send
      - GET /api/v1/notifications/history
```

### 3.2 前端架构设计

#### 3.2.1 Flutter应用架构

**应用结构组织**：
```
lib/
├── main.dart                    # 应用入口
├── app.dart                     # 应用根组件
├── core/                        # 核心配置
│   ├── constants/               # 常量定义
│   ├── errors/                  # 错误处理
│   ├── network/                 # 网络配置
│   ├── themes/                  # 主题配置
│   └── utils/                   # 工具函数
├── data/                        # 数据层
│   ├── datasources/             # 数据源
│   ├── models/                  # 数据模型
│   └── repositories/            # 仓库模式
├── domain/                      # 业务层
│   ├── entities/                # 业务实体
│   ├── repositories/            # 仓库接口
│   └── usecases/                # 业务用例
├── presentation/                # 表现层
│   ├── bloc/                    # 状态管理
│   ├── pages/                   # 页面组件
│   ├── widgets/                 # 通用组件
│   └── routes/                  # 路由配置
└── services/                    # 外部服务
    ├── api_client.dart          # API客户端
    ├── storage_service.dart     # 存储服务
    └── notification_service.dart # 通知服务
```

**Clean Architecture实现**：
```dart
// domain/entities/fund.dart - 业务实体
class Fund {
  final String code;
  final String name;
  final String type;
  final String company;
  final double? latestNav;
  final DateTime? latestDate;
  final List<FundNavHistory> navHistory;

  Fund({
    required this.code,
    required this.name,
    required this.type,
    required this.company,
    this.latestNav,
    this.latestDate,
    this.navHistory = const [],
  });

  // 业务逻辑方法
  double getDailyChange() {
    if (navHistory.isEmpty) return 0.0;
    final yesterday = navHistory.lastWhere(
      (item) => item.date.isBefore(latestDate ?? DateTime.now()),
      orElse: () => navHistory.last,
    );
    return latestNav! - yesterday.navValue;
  }

  double getDailyChangeRate() {
    final change = getDailyChange();
    if (yesterdayNav <= 0) return 0.0;
    return (change / yesterdayNav) * 100;
  }
}

// domain/repositories/fund_repository.dart - 仓库接口
abstract class FundRepository {
  Future<List<Fund>> getFunds({FundFilter? filter});
  Future<Fund?> getFundByCode(String code);
  Future<List<Fund>> searchFunds(String query);
  Future<List<FundNavHistory>> getNavHistory(String code, {DateRange? range});
}

// data/repositories/fund_repository_impl.dart - 仓库实现
class FundRepositoryImpl implements FundRepository {
  final FundRemoteDataSource remoteDataSource;
  final FundLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  FundRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<List<Fund>> getFunds({FundFilter? filter}) async {
    if (await networkInfo.isConnected) {
      try {
        final remoteFunds = await remoteDataSource.getFunds(filter);
        await localDataSource.cacheFunds(remoteFunds);
        return remoteFunds;
      } catch (e) {
        return localDataSource.getCachedFunds(filter);
      }
    } else {
      return localDataSource.getCachedFunds(filter);
    }
  }
}

// domain/usecases/get_funds.dart - 业务用例
class GetFunds implements UseCase<List<Fund>, FundFilterParams> {
  final FundRepository repository;

  GetFunds(this.repository);

  @override
  Future<Either<Failure, List<Fund>>> call(FundFilterParams params) async {
    try {
      final funds = await repository.getFunds(filter: params.filter);
      return Right(funds);
    } on ServerException {
      return Left(ServerFailure());
    } on NetworkException {
      return Left(NetworkFailure());
    }
  }
}
```

#### 3.2.2 状态管理架构

**BLoC架构模式**：
```dart
// presentation/bloc/fund_bloc/fund_bloc.dart
class FundBloc extends Bloc<FundEvent, FundState> {
  final GetFunds getFunds;
  final SearchFunds searchFunds;
  final ToggleFavorite toggleFavorite;

  FundBloc({
    required this.getFunds,
    required this.searchFunds,
    required this.toggleFavorite,
  }) : super(FundInitial()) {
    on<GetFundsEvent>(_onGetFunds);
    on<SearchFundsEvent>(_onSearchFunds);
    on<ToggleFavoriteEvent>(_onToggleFavorite);
    on<RefreshFundsEvent>(_onRefreshFunds);
  }

  Future<void> _onGetFunds(
    GetFundsEvent event,
    Emitter<FundState> emit,
  ) async {
    emit(FundLoading());

    final result = await getFunds(FundFilterParams(filter: event.filter));

    result.fold(
      (failure) => emit(FundError(failure.message)),
      (funds) => emit(FundLoaded(funds)),
    );
  }

  Future<void> _onSearchFunds(
    SearchFundsEvent event,
    Emitter<FundState> emit,
  ) async {
    if (event.query.isEmpty) {
      emit(FundInitial());
      return;
    }

    emit(FundSearchLoading());

    final result = await searchFunds(event.query);

    result.fold(
      (failure) => emit(FundSearchError(failure.message)),
      (funds) => emit(FundSearchLoaded(funds)),
    );
  }
}

// presentation/bloc/fund_bloc/fund_state.dart
abstract class FundState extends Equatable {
  const FundState();

  @override
  List<Object> get props => [];
}

class FundInitial extends FundState {}

class FundLoading extends FundState {}

class FundLoaded extends FundState {
  final List<Fund> funds;
  final FundFilter? currentFilter;

  const FundLoaded(this.funds, {this.currentFilter});

  @override
  List<Object> get props => [funds, currentFilter];
}

class FundError extends FundState {
  final String message;

  const FundError(this.message);

  @override
  List<Object> get props => [message];
}
```

### 3.3 后端架构设计

#### 3.3.1 API网关架构

**API网关设计模式**：
```python
# gateway/api_gateway.py - API网关实现
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
import httpx
import asyncio
from typing import Dict, Any

class APIGateway:
    def __init__(self):
        self.app = FastAPI(title="基速API网关")
        self.services = {
            'fund_data': 'http://fund-data-service:8001',
            'analysis': 'http://analysis-service:8002',
            'user': 'http://user-service:8003',
            'notification': 'http://notification-service:8004',
        }
        self.setup_middleware()
        self.setup_routes()

    def setup_middleware(self):
        """设置中间件"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

        self.app.add_middleware(HTTPSRedirectMiddleware)

    def setup_routes(self):
        """设置路由"""
        @self.app.middleware("http")
        async def rate_limiting(request: Request, call_next):
            """限流中间件"""
            client_ip = request.client.host
            # 实现限流逻辑
            response = await call_next(request)
            return response

        @self.app.middleware("http")
        async def auth_middleware(request: Request, call_next):
            """认证中间件"""
            if request.url.path.startswith("/api/v1/user/"):
                token = request.headers.get("Authorization")
                if not await self.validate_token(token):
                    raise HTTPException(status_code=401, detail="Invalid token")

            response = await call_next(request)
            return response

    async def validate_token(self, token: str) -> bool:
        """验证JWT令牌"""
        try:
            # 实现JWT验证逻辑
            return True
        except:
            return False

    async def proxy_request(
        self,
        service_name: str,
        path: str,
        method: str,
        headers: Dict[str, str],
        body: bytes = None,
    ) -> Any:
        """代理请求到微服务"""
        service_url = self.services.get(service_name)
        if not service_url:
            raise HTTPException(status_code=404, detail="Service not found")

        url = f"{service_url}{path}"

        async with httpx.AsyncClient() as client:
            response = await client.request(
                method=method,
                url=url,
                headers=headers,
                content=body,
            )
            return response.json()

# 路由配置
@router.api_route("/api/v1/funds/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def fund_service_proxy(request: Request, path: str):
    gateway = APIGateway()
    return await gateway.proxy_request(
        service_name="fund_data",
        path=f"/{path}",
        method=request.method,
        headers=dict(request.headers),
        body=await request.body(),
    )
```

#### 3.3.2 微服务通信架构

**服务间通信模式**：
```python
# services/fund_data_service/main.py - 基金数据服务
from fastapi import FastAPI, BackgroundTasks
from fastapi.dependencies import Depends
import asyncio
from typing import List

app = FastAPI(title="基金数据服务")

class FundDataService:
    def __init__(self):
        self.cache = RedisCache()
        self.database = PostgreSQLConnection()
        self.message_queue = RabbitMQConnection()

    async def get_funds(self, filter: FundFilter = None) -> List[Fund]:
        """获取基金列表"""
        cache_key = f"funds:{filter.to_cache_key() if filter else 'all'}"

        # 尝试从缓存获取
        cached_funds = await self.cache.get(cache_key)
        if cached_funds:
            return cached_funds

        # 从数据库获取
        funds = await self.database.get_funds(filter)

        # 缓存结果
        await self.cache.set(cache_key, funds, ttl=3600)

        return funds

    async def update_fund_data(self, fund_code: str):
        """更新基金数据"""
        try:
            # 获取最新数据
            latest_data = await self.fetch_fund_data_from_api(fund_code)

            # 更新数据库
            await self.database.update_fund(fund_code, latest_data)

            # 发送更新事件
            await self.message_queue.publish(
                exchange="fund_updates",
                routing_key=f"fund.updated.{fund_code}",
                message={
                    "fund_code": fund_code,
                    "timestamp": datetime.utcnow().isoformat(),
                    "data": latest_data,
                }
            )

            # 清除相关缓存
            await self.cache.delete_pattern(f"funds:*")

        except Exception as e:
            logger.error(f"Failed to update fund {fund_code}: {e}")
            raise

# 事件监听
@app.post("/webhooks/fund-updated")
async def handle_fund_updated_event(event: FundUpdatedEvent):
    """处理基金更新事件"""
    service = FundDataService()

    # 触发相关服务更新
    await service.message_queue.publish(
        exchange="data_updates",
        routing_key="analysis.trigger",
        message={
            "fund_code": event.fund_code,
            "trigger_type": "fund_updated",
        }
    )

    return {"status": "processed"}
```

### 3.4 数据架构设计

#### 3.4.1 数据库架构

**分库分表策略**：
```sql
-- 基金数据库 (fund_db)
CREATE DATABASE fund_db;

-- 用户数据库 (user_db)
CREATE DATABASE user_db;

-- 分析数据库 (analysis_db)
CREATE DATABASE analysis_db;

-- 基金数据表设计
CREATE TABLE fund_db.funds (
    code VARCHAR(10) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    company VARCHAR(50) NOT NULL,
    -- 其他字段...
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (code);

-- 按基金代码哈希分片
CREATE TABLE fund_db.funds_0 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE fund_db.funds_1 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE fund_db.funds_2 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE fund_db.funds_3 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- 基金净值历史表 (按时间分区)
CREATE TABLE fund_db.fund_nav_history (
    id BIGSERIAL,
    fund_code VARCHAR(10) NOT NULL,
    nav_date DATE NOT NULL,
    nav_value NUMERIC(12, 4) NOT NULL,
    accumulated_nav NUMERIC(12, 4),
    daily_change NUMERIC(8, 4),
    daily_change_rate NUMERIC(8, 4),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id, nav_date)
) PARTITION BY RANGE (nav_date);

-- 按月分区
CREATE TABLE fund_db.fund_nav_history_202401 PARTITION OF fund_db.fund_nav_history
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE fund_db.fund_nav_history_202402 PARTITION OF fund_db.fund_nav_history
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

**读写分离架构**：
```python
# database/db_manager.py - 数据库管理器
import asyncpg
from typing import Union, Dict, Any
from contextlib import asynccontextmanager

class DatabaseManager:
    def __init__(self, config: DatabaseConfig):
        self.master_config = config.master
        self.slave_configs = config.slaves
        self.current_slave_index = 0

    async def get_master_connection(self):
        """获取主库连接（写操作）"""
        return await asyncpg.connect(
            **self.master_config.dict(),
            min_size=5,
            max_size=20,
        )

    async def get_slave_connection(self):
        """获取从库连接（读操作）"""
        slave_config = self.get_next_slave_config()
        return await asyncpg.connect(
            **slave_config.dict(),
            min_size=5,
            max_size=20,
        )

    def get_next_slave_config(self):
        """轮询获取从库配置"""
        config = self.slave_configs[self.current_slave_index]
        self.current_slave_index = (self.current_slave_index + 1) % len(self.slave_configs)
        return config

    @asynccontextmanager
    async def get_connection(self, read_only: bool = False):
        """获取数据库连接上下文管理器"""
        if read_only:
            conn = await self.get_slave_connection()
        else:
            conn = await self.get_master_connection()

        try:
            yield conn
        except Exception:
            await conn.rollback()
            raise
        finally:
            await conn.close()

    async def execute_query(
        self,
        query: str,
        params: Dict[str, Any] = None,
        read_only: bool = False,
    ) -> Any:
        """执行SQL查询"""
        async with self.get_connection(read_only=read_only) as conn:
            if read_only:
                return await conn.fetch(query, *params.values() if params else [])
            else:
                return await conn.execute(query, *params.values() if params else [])
```

#### 3.4.2 缓存架构

**多级缓存策略**：
```python
# cache/cache_manager.py - 缓存管理器
import redis
import asyncio
from typing import Any, Optional, Union
from dataclasses import dataclass

@dataclass
class CacheConfig:
    local_cache_size: int = 1000
    local_cache_ttl: int = 300  # 5分钟
    redis_ttl: int = 3600       # 1小时

class MultiLevelCache:
    def __init__(self, config: CacheConfig):
        self.config = config
        self.local_cache = {}  # 简化的内存缓存
        self.redis_client = redis.Redis.from_url("redis://localhost:6379")
        self.cache_stats = {
            "local_hits": 0,
            "redis_hits": 0,
            "misses": 0,
        }

    async def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        # 第一级：本地缓存
        if key in self.local_cache:
            self.cache_stats["local_hits"] += 1
            return self.local_cache[key]

        # 第二级：Redis缓存
        redis_data = await self._get_from_redis(key)
        if redis_data:
            self.cache_stats["redis_hits"] += 1
            # 回填本地缓存
            self.local_cache[key] = redis_data
            return redis_data

        # 缓存未命中
        self.cache_stats["misses"] += 1
        return None

    async def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[int] = None,
    ) -> bool:
        """设置缓存数据"""
        try:
            # 设置本地缓存
            self.local_cache[key] = value

            # 设置Redis缓存
            redis_ttl = ttl or self.config.redis_ttl
            await self._set_to_redis(key, value, redis_ttl)

            # 本地缓存过期处理
            asyncio.create_task(
                self._expire_local_cache(key, ttl or self.config.local_cache_ttl)
            )

            return True
        except Exception as e:
            logger.error(f"Cache set error: {e}")
            return False

    async def _get_from_redis(self, key: str) -> Optional[Any]:
        """从Redis获取数据"""
        try:
            data = self.redis_client.get(key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logger.error(f"Redis get error: {e}")
            return None

    async def _set_to_redis(self, key: str, value: Any, ttl: int) -> bool:
        """设置Redis数据"""
        try:
            return self.redis_client.setex(
                key, ttl, json.dumps(value, default=str)
            )
        except Exception as e:
            logger.error(f"Redis set error: {e}")
            return False

    async def _expire_local_cache(self, key: str, ttl: int):
        """本地缓存过期"""
        await asyncio.sleep(ttl)
        if key in self.local_cache:
            del self.local_cache[key]

    def get_cache_stats(self) -> Dict[str, int]:
        """获取缓存统计"""
        total_requests = (
            self.cache_stats["local_hits"] +
            self.cache_stats["redis_hits"] +
            self.cache_stats["misses"]
        )

        if total_requests == 0:
            return self.cache_stats

        return {
            **self.cache_stats,
            "hit_rate": (
                self.cache_stats["local_hits"] + self.cache_stats["redis_hits"]
            ) / total_requests,
            "local_hit_rate": self.cache_stats["local_hits"] / total_requests,
            "redis_hit_rate": self.cache_stats["redis_hits"] / total_requests,
        }
```

### 3.5 消息队列架构

#### 3.5.1 事件驱动架构

**消息队列设计**：
```python
# messaging/message_queue.py - 消息队列管理
import asyncio
from typing import Dict, Any, Callable
import aio_pika
from dataclasses import dataclass

@dataclass
class Message:
    exchange: str
    routing_key: str
    payload: Dict[str, Any]
    headers: Dict[str, Any] = None

class MessageQueue:
    def __init__(self, connection_url: str):
        self.connection_url = connection_url
        self.connection = None
        self.channel = None
        self.exchanges = {}
        self.consumers = {}

    async def connect(self):
        """连接到消息队列"""
        self.connection = await aio_pika.connect_robust(self.connection_url)
        self.channel = await self.connection.channel()

    async def setup_exchanges(self):
        """设置交换机"""
        exchanges_config = {
            "fund_updates": aio_pika.ExchangeType.TOPIC,
            "data_updates": aio_pika.ExchangeType.TOPIC,
            "user_events": aio_pika.ExchangeType.TOPIC,
            "notifications": aio_pika.ExchangeType.FANOUT,
        }

        for exchange_name, exchange_type in exchanges_config.items():
            exchange = await self.channel.declare_exchange(
                exchange_name, exchange_type, durable=True
            )
            self.exchanges[exchange_name] = exchange

    async def publish_message(self, message: Message) -> bool:
        """发布消息"""
        try:
            exchange = self.exchanges.get(message.exchange)
            if not exchange:
                raise ValueError(f"Exchange {message.exchange} not found")

            message_body = aio_pika.Message(
                json.dumps(message.payload).encode(),
                content_type="application/json",
                headers=message.headers or {},
                delivery_mode=2,  # 持久化消息
            )

            await exchange.publish(
                message_body,
                routing_key=message.routing_key,
            )
            return True
        except Exception as e:
            logger.error(f"Failed to publish message: {e}")
            return False

    async def subscribe_to_queue(
        self,
        queue_name: str,
        exchange_name: str,
        routing_key: str,
        callback: Callable[[Dict[str, Any]], None],
    ) -> str:
        """订阅队列"""
        try:
            exchange = self.exchanges.get(exchange_name)
            if not exchange:
                raise ValueError(f"Exchange {exchange_name} not found")

            # 声明队列
            queue = await self.channel.declare_queue(
                queue_name, durable=True
            )

            # 绑定队列到交换机
            await queue.bind(exchange, routing_key)

            # 创建消费者
            async def message_handler(message: aio_pika.IncomingMessage):
                async with message.process():
                    try:
                        payload = json.loads(message.body.decode())
                        await callback(payload)
                    except Exception as e:
                        logger.error(f"Message handler error: {e}")

            consumer_tag = await queue.consume(message_handler)
            self.consumers[queue_name] = consumer_tag

            return consumer_tag
        except Exception as e:
            logger.error(f"Failed to subscribe to queue: {e}")
            raise

# 事件处理示例
class FundEventHandler:
    def __init__(self, message_queue: MessageQueue):
        self.message_queue = message_queue

    async def handle_fund_updated(self, event: Dict[str, Any]):
        """处理基金更新事件"""
        fund_code = event.get("fund_code")

        # 触发相关分析服务
        await self.message_queue.publish_message(Message(
            exchange="data_updates",
            routing_key="analysis.trigger",
            payload={
                "fund_code": fund_code,
                "trigger_type": "fund_updated",
                "timestamp": datetime.utcnow().isoformat(),
            }
        ))

        # 发送通知给关注该基金的用户
        await self.message_queue.publish_message(Message(
            exchange="notifications",
            routing_key="fund.updated",
            payload={
                "fund_code": fund_code,
                "message": f"基金 {fund_code} 数据已更新",
                "timestamp": datetime.utcnow().isoformat(),
            }
        ))
```

### 3.6 监控和可观测性

#### 3.6.1 分布式追踪

**OpenTelemetry集成**：
```python
# monitoring/tracing.py - 分布式追踪
from opentelemetry import trace, baggage, context
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
import functools

class TracingManager:
    def __init__(self):
        self.setup_tracing()

    def setup_tracing(self):
        """设置分布式追踪"""
        trace.set_tracer_provider(TracerProvider())
        tracer = trace.get_tracer(__name__)

        jaeger_exporter = JaegerExporter(
            agent_host_name="localhost",
            agent_port=6831,
        )

        span_processor = BatchSpanProcessor(jaeger_exporter)
        trace.get_tracer_provider().add_span_processor(span_processor)

    def trace_function(self, operation_name: str):
        """函数追踪装饰器"""
        def decorator(func):
            @functools.wraps(func)
            async def wrapper(*args, **kwargs):
                tracer = trace.get_tracer(__name__)

                with tracer.start_as_current_span(operation_name) as span:
                    span.set_attribute("function.name", func.__name__)
                    span.set_attribute("function.module", func.__module__)

                    try:
                        result = await func(*args, **kwargs)
                        span.set_status(trace.Status(trace.StatusCode.OK))
                        return result
                    except Exception as e:
                        span.set_status(
                            trace.Status(
                                trace.StatusCode.ERROR,
                                description=str(e)
                            )
                        )
                        span.record_exception(e)
                        raise
            return wrapper
        return decorator

# 使用示例
tracing_manager = TracingManager()

@tracing_manager.trace_function("get_fund_data")
async def get_fund_data(fund_code: str) -> Fund:
    # 实现获取基金数据的逻辑
    pass

# FastAPI集成
app = FastAPI()
FastAPIInstrumentor.instrument_app(app)
SQLAlchemyInstrumentor().instrument(engine=engine)
```

---

*本章节详细说明了基速平台的系统架构设计，包括前端架构、后端微服务、数据架构、消息队列等各个层面的设计方案*