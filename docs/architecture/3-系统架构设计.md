# 3. ç³»ç»Ÿæ¶æ„è®¾è®¡

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ¦‚è¿°

åŸºé€ŸåŸºé‡‘é‡åŒ–åˆ†æå¹³å°é‡‡ç”¨ç°ä»£åŒ–çš„åˆ†å±‚æ¶æ„æ¨¡å¼ï¼Œç»“åˆå¾®æœåŠ¡ç†å¿µå’Œäº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œç¡®ä¿ç³»ç»Ÿçš„é«˜å¯ç”¨æ€§ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚æœ¬ç« èŠ‚è¯¦ç»†è¯´æ˜ç³»ç»Ÿçš„æ•´ä½“æ¶æ„è®¾è®¡å’Œå„å±‚ç»„ä»¶çš„è®¾è®¡æ–¹æ¡ˆã€‚

### 3.1 æ•´ä½“æ¶æ„æ¨¡å¼

#### 3.1.1 å››å±‚æ¶æ„æ¨¡å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç°å±‚ (Presentation Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Web Client    â”‚  â”‚  Mobile Client  â”‚  â”‚ Desktop Client  â”‚ â”‚
â”‚  â”‚  (Flutter Web)  â”‚  â”‚  (Flutter App)  â”‚  â”‚ (Flutter App)   â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚ - è·¯ç”±ç®¡ç†       â”‚  â”‚ - é¡µé¢å¯¼èˆª       â”‚  â”‚ - çª—å£ç®¡ç†       â”‚ â”‚
â”‚  â”‚ - çŠ¶æ€ç®¡ç†       â”‚  â”‚ - æœ¬åœ°å­˜å‚¨       â”‚  â”‚ - æ–‡ä»¶æ“ä½œ       â”‚ â”‚
â”‚  â”‚ - UIç»„ä»¶        â”‚  â”‚ - ç½‘ç»œè¯·æ±‚       â”‚  â”‚ - ç³»ç»Ÿé›†æˆ       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   çŠ¶æ€ç®¡ç†       â”‚  â”‚   ä¸šåŠ¡æœåŠ¡       â”‚  â”‚   æ•°æ®å¤„ç†       â”‚ â”‚
â”‚  â”‚   (BLoC)        â”‚  â”‚ (Services)      â”‚  â”‚ (Utils)         â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚ - çŠ¶æ€çŠ¶æ€ç®¡ç†    â”‚  â”‚ - ä¸šåŠ¡é€»è¾‘       â”‚  â”‚ - æ•°æ®è®¡ç®—       â”‚ â”‚
â”‚  â”‚ - äº‹ä»¶åˆ†å‘       â”‚  â”‚ - æ•°æ®éªŒè¯       â”‚  â”‚ - æ ¼å¼è½¬æ¢       â”‚ â”‚
â”‚  â”‚ - æ•°æ®åŒæ­¥       â”‚  â”‚ - ä¸šåŠ¡è§„åˆ™       â”‚  â”‚ - ç®—æ³•å®ç°       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ•°æ®è®¿é—®å±‚ (Data Access Layer)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   ç½‘ç»œå®¢æˆ·ç«¯      â”‚  â”‚   æœ¬åœ°ç¼“å­˜       â”‚  â”‚   æ•°æ®æŒä¹…åŒ–     â”‚ â”‚
â”‚  â”‚   (Dio)         â”‚  â”‚   (Hive)        â”‚  â”‚ (SharedPrefs)   â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚ - HTTPè¯·æ±‚       â”‚  â”‚ - å†…å­˜ç¼“å­˜       â”‚  â”‚ - ç”¨æˆ·è®¾ç½®       â”‚ â”‚
â”‚  â”‚ - é”™è¯¯å¤„ç†       â”‚  â”‚ - æ•°æ®æŒä¹…åŒ–     â”‚  â”‚ - åº”ç”¨é…ç½®       â”‚ â”‚
â”‚  â”‚ - è¯·æ±‚æ‹¦æˆª       â”‚  â”‚ - ç¦»çº¿æ”¯æŒ       â”‚  â”‚ - ä¸´æ—¶æ•°æ®       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   APIç½‘å…³        â”‚  â”‚   å¾®æœåŠ¡é›†ç¾¤     â”‚  â”‚   æ•°æ®å­˜å‚¨       â”‚ â”‚
â”‚  â”‚ (API Gateway)   â”‚  â”‚ (Microservices)  â”‚  â”‚ (Data Store)    â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚ - è·¯ç”±åˆ†å‘       â”‚  â”‚ - åŸºé‡‘æ•°æ®æœåŠ¡   â”‚  â”‚ - PostgreSQL    â”‚ â”‚
â”‚  â”‚ - è®¤è¯æˆæƒ       â”‚  â”‚ - åˆ†æè®¡ç®—æœåŠ¡   â”‚  â”‚ - Redisç¼“å­˜     â”‚ â”‚
â”‚  â”‚ - é™æµæ§åˆ¶       â”‚  â”‚ - ç”¨æˆ·æœåŠ¡       â”‚  â”‚ - æ–‡ä»¶å­˜å‚¨       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.1.2 å¾®æœåŠ¡æ¶æ„è®¾è®¡

**æœåŠ¡æ‹†åˆ†åŸåˆ™**ï¼š
- **ä¸šåŠ¡è¾¹ç•Œæ˜ç¡®**: æŒ‰ç…§ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†æœåŠ¡
- **æ•°æ®ç‹¬ç«‹æ€§**: æ¯ä¸ªæœåŠ¡æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®å­˜å‚¨
- **å•ä¸€èŒè´£**: æ¯ä¸ªæœåŠ¡ä¸“æ³¨äºå•ä¸€ä¸šåŠ¡é¢†åŸŸ
- **æ¥å£æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„APIæ¥å£è§„èŒƒ

**æ ¸å¿ƒå¾®æœåŠ¡ç»„ä»¶**ï¼š
```yaml
microservices:
  # åŸºé‡‘æ•°æ®æœåŠ¡
  fund_data_service:
    description: "åŸºé‡‘æ•°æ®ç®¡ç†æ ¸å¿ƒæœåŠ¡"
    responsibilities:
      - åŸºé‡‘ä¿¡æ¯æŸ¥è¯¢å’Œç®¡ç†
      - åŸºé‡‘å‡€å€¼æ•°æ®è·å–
      - æ•°æ®æ¸…æ´—å’ŒéªŒè¯
    endpoints:
      - GET /api/v1/funds
      - GET /api/v1/funds/{code}
      - GET /api/v1/funds/{code}/nav-history

  # åˆ†æè®¡ç®—æœåŠ¡
  analysis_service:
    description: "é‡åŒ–åˆ†æå’Œè®¡ç®—æœåŠ¡"
    responsibilities:
      - æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
      - é£é™©è¯„ä¼°ç®—æ³•
      - æ”¶ç›Šåˆ†æè®¡ç®—
    endpoints:
      - POST /api/v1/analysis/indicators
      - POST /api/v1/analysis/risk-assessment
      - POST /api/v1/analysis/portfolio-analysis

  # ç”¨æˆ·æœåŠ¡
  user_service:
    description: "ç”¨æˆ·ç®¡ç†å’Œä¸ªæ€§åŒ–æœåŠ¡"
    responsibilities:
      - ç”¨æˆ·è®¤è¯å’Œæˆæƒ
      - ç”¨æˆ·åå¥½ç®¡ç†
      - æ”¶è—å’Œå†å²è®°å½•
    endpoints:
      - POST /api/v1/auth/login
      - GET /api/v1/users/profile
      - POST /api/v1/users/favorites

  # é€šçŸ¥æœåŠ¡
  notification_service:
    description: "æ¶ˆæ¯æ¨é€å’Œé€šçŸ¥æœåŠ¡"
    responsibilities:
      - å®æ—¶æ•°æ®æ¨é€
      - ä»·æ ¼é¢„è­¦é€šçŸ¥
      - ç³»ç»Ÿæ¶ˆæ¯ç®¡ç†
    endpoints:
      - POST /api/v1/notifications/subscribe
      - POST /api/v1/notifications/send
      - GET /api/v1/notifications/history
```

### 3.2 å‰ç«¯æ¶æ„è®¾è®¡

#### 3.2.1 Flutteråº”ç”¨æ¶æ„

**åº”ç”¨ç»“æ„ç»„ç»‡**ï¼š
```
lib/
â”œâ”€â”€ main.dart                    # åº”ç”¨å…¥å£
â”œâ”€â”€ app.dart                     # åº”ç”¨æ ¹ç»„ä»¶
â”œâ”€â”€ core/                        # æ ¸å¿ƒé…ç½®
â”‚   â”œâ”€â”€ constants/               # å¸¸é‡å®šä¹‰
â”‚   â”œâ”€â”€ errors/                  # é”™è¯¯å¤„ç†
â”‚   â”œâ”€â”€ network/                 # ç½‘ç»œé…ç½®
â”‚   â”œâ”€â”€ themes/                  # ä¸»é¢˜é…ç½®
â”‚   â””â”€â”€ utils/                   # å·¥å…·å‡½æ•°
â”œâ”€â”€ data/                        # æ•°æ®å±‚
â”‚   â”œâ”€â”€ datasources/             # æ•°æ®æº
â”‚   â”œâ”€â”€ models/                  # æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ repositories/            # ä»“åº“æ¨¡å¼
â”œâ”€â”€ domain/                      # ä¸šåŠ¡å±‚
â”‚   â”œâ”€â”€ entities/                # ä¸šåŠ¡å®ä½“
â”‚   â”œâ”€â”€ repositories/            # ä»“åº“æ¥å£
â”‚   â””â”€â”€ usecases/                # ä¸šåŠ¡ç”¨ä¾‹
â”œâ”€â”€ presentation/                # è¡¨ç°å±‚
â”‚   â”œâ”€â”€ bloc/                    # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ pages/                   # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ widgets/                 # é€šç”¨ç»„ä»¶
â”‚   â””â”€â”€ routes/                  # è·¯ç”±é…ç½®
â””â”€â”€ services/                    # å¤–éƒ¨æœåŠ¡
    â”œâ”€â”€ api_client.dart          # APIå®¢æˆ·ç«¯
    â”œâ”€â”€ storage_service.dart     # å­˜å‚¨æœåŠ¡
    â””â”€â”€ notification_service.dart # é€šçŸ¥æœåŠ¡
```

**Clean Architectureå®ç°**ï¼š
```dart
// domain/entities/fund.dart - ä¸šåŠ¡å®ä½“
class Fund {
  final String code;
  final String name;
  final String type;
  final String company;
  final double? latestNav;
  final DateTime? latestDate;
  final List<FundNavHistory> navHistory;

  Fund({
    required this.code,
    required this.name,
    required this.type,
    required this.company,
    this.latestNav,
    this.latestDate,
    this.navHistory = const [],
  });

  // ä¸šåŠ¡é€»è¾‘æ–¹æ³•
  double getDailyChange() {
    if (navHistory.isEmpty) return 0.0;
    final yesterday = navHistory.lastWhere(
      (item) => item.date.isBefore(latestDate ?? DateTime.now()),
      orElse: () => navHistory.last,
    );
    return latestNav! - yesterday.navValue;
  }

  double getDailyChangeRate() {
    final change = getDailyChange();
    if (yesterdayNav <= 0) return 0.0;
    return (change / yesterdayNav) * 100;
  }
}

// domain/repositories/fund_repository.dart - ä»“åº“æ¥å£
abstract class FundRepository {
  Future<List<Fund>> getFunds({FundFilter? filter});
  Future<Fund?> getFundByCode(String code);
  Future<List<Fund>> searchFunds(String query);
  Future<List<FundNavHistory>> getNavHistory(String code, {DateRange? range});
}

// data/repositories/fund_repository_impl.dart - ä»“åº“å®ç°
class FundRepositoryImpl implements FundRepository {
  final FundRemoteDataSource remoteDataSource;
  final FundLocalDataSource localDataSource;
  final NetworkInfo networkInfo;

  FundRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
    required this.networkInfo,
  });

  @override
  Future<List<Fund>> getFunds({FundFilter? filter}) async {
    if (await networkInfo.isConnected) {
      try {
        final remoteFunds = await remoteDataSource.getFunds(filter);
        await localDataSource.cacheFunds(remoteFunds);
        return remoteFunds;
      } catch (e) {
        return localDataSource.getCachedFunds(filter);
      }
    } else {
      return localDataSource.getCachedFunds(filter);
    }
  }
}

// domain/usecases/get_funds.dart - ä¸šåŠ¡ç”¨ä¾‹
class GetFunds implements UseCase<List<Fund>, FundFilterParams> {
  final FundRepository repository;

  GetFunds(this.repository);

  @override
  Future<Either<Failure, List<Fund>>> call(FundFilterParams params) async {
    try {
      final funds = await repository.getFunds(filter: params.filter);
      return Right(funds);
    } on ServerException {
      return Left(ServerFailure());
    } on NetworkException {
      return Left(NetworkFailure());
    }
  }
}
```

#### 3.2.2 çŠ¶æ€ç®¡ç†æ¶æ„

**BLoCæ¶æ„æ¨¡å¼**ï¼š
```dart
// presentation/bloc/fund_bloc/fund_bloc.dart
class FundBloc extends Bloc<FundEvent, FundState> {
  final GetFunds getFunds;
  final SearchFunds searchFunds;
  final ToggleFavorite toggleFavorite;

  FundBloc({
    required this.getFunds,
    required this.searchFunds,
    required this.toggleFavorite,
  }) : super(FundInitial()) {
    on<GetFundsEvent>(_onGetFunds);
    on<SearchFundsEvent>(_onSearchFunds);
    on<ToggleFavoriteEvent>(_onToggleFavorite);
    on<RefreshFundsEvent>(_onRefreshFunds);
  }

  Future<void> _onGetFunds(
    GetFundsEvent event,
    Emitter<FundState> emit,
  ) async {
    emit(FundLoading());

    final result = await getFunds(FundFilterParams(filter: event.filter));

    result.fold(
      (failure) => emit(FundError(failure.message)),
      (funds) => emit(FundLoaded(funds)),
    );
  }

  Future<void> _onSearchFunds(
    SearchFundsEvent event,
    Emitter<FundState> emit,
  ) async {
    if (event.query.isEmpty) {
      emit(FundInitial());
      return;
    }

    emit(FundSearchLoading());

    final result = await searchFunds(event.query);

    result.fold(
      (failure) => emit(FundSearchError(failure.message)),
      (funds) => emit(FundSearchLoaded(funds)),
    );
  }
}

// presentation/bloc/fund_bloc/fund_state.dart
abstract class FundState extends Equatable {
  const FundState();

  @override
  List<Object> get props => [];
}

class FundInitial extends FundState {}

class FundLoading extends FundState {}

class FundLoaded extends FundState {
  final List<Fund> funds;
  final FundFilter? currentFilter;

  const FundLoaded(this.funds, {this.currentFilter});

  @override
  List<Object> get props => [funds, currentFilter];
}

class FundError extends FundState {
  final String message;

  const FundError(this.message);

  @override
  List<Object> get props => [message];
}
```

### 3.3 åç«¯æ¶æ„è®¾è®¡

#### 3.3.1 APIç½‘å…³æ¶æ„

**APIç½‘å…³è®¾è®¡æ¨¡å¼**ï¼š
```python
# gateway/api_gateway.py - APIç½‘å…³å®ç°
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
import httpx
import asyncio
from typing import Dict, Any

class APIGateway:
    def __init__(self):
        self.app = FastAPI(title="åŸºé€ŸAPIç½‘å…³")
        self.services = {
            'fund_data': 'http://fund-data-service:8001',
            'analysis': 'http://analysis-service:8002',
            'user': 'http://user-service:8003',
            'notification': 'http://notification-service:8004',
        }
        self.setup_middleware()
        self.setup_routes()

    def setup_middleware(self):
        """è®¾ç½®ä¸­é—´ä»¶"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )

        self.app.add_middleware(HTTPSRedirectMiddleware)

    def setup_routes(self):
        """è®¾ç½®è·¯ç”±"""
        @self.app.middleware("http")
        async def rate_limiting(request: Request, call_next):
            """é™æµä¸­é—´ä»¶"""
            client_ip = request.client.host
            # å®ç°é™æµé€»è¾‘
            response = await call_next(request)
            return response

        @self.app.middleware("http")
        async def auth_middleware(request: Request, call_next):
            """è®¤è¯ä¸­é—´ä»¶"""
            if request.url.path.startswith("/api/v1/user/"):
                token = request.headers.get("Authorization")
                if not await self.validate_token(token):
                    raise HTTPException(status_code=401, detail="Invalid token")

            response = await call_next(request)
            return response

    async def validate_token(self, token: str) -> bool:
        """éªŒè¯JWTä»¤ç‰Œ"""
        try:
            # å®ç°JWTéªŒè¯é€»è¾‘
            return True
        except:
            return False

    async def proxy_request(
        self,
        service_name: str,
        path: str,
        method: str,
        headers: Dict[str, str],
        body: bytes = None,
    ) -> Any:
        """ä»£ç†è¯·æ±‚åˆ°å¾®æœåŠ¡"""
        service_url = self.services.get(service_name)
        if not service_url:
            raise HTTPException(status_code=404, detail="Service not found")

        url = f"{service_url}{path}"

        async with httpx.AsyncClient() as client:
            response = await client.request(
                method=method,
                url=url,
                headers=headers,
                content=body,
            )
            return response.json()

# è·¯ç”±é…ç½®
@router.api_route("/api/v1/funds/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def fund_service_proxy(request: Request, path: str):
    gateway = APIGateway()
    return await gateway.proxy_request(
        service_name="fund_data",
        path=f"/{path}",
        method=request.method,
        headers=dict(request.headers),
        body=await request.body(),
    )
```

#### 3.3.2 å¾®æœåŠ¡é€šä¿¡æ¶æ„

**æœåŠ¡é—´é€šä¿¡æ¨¡å¼**ï¼š
```python
# services/fund_data_service/main.py - åŸºé‡‘æ•°æ®æœåŠ¡
from fastapi import FastAPI, BackgroundTasks
from fastapi.dependencies import Depends
import asyncio
from typing import List

app = FastAPI(title="åŸºé‡‘æ•°æ®æœåŠ¡")

class FundDataService:
    def __init__(self):
        self.cache = RedisCache()
        self.database = PostgreSQLConnection()
        self.message_queue = RabbitMQConnection()

    async def get_funds(self, filter: FundFilter = None) -> List[Fund]:
        """è·å–åŸºé‡‘åˆ—è¡¨"""
        cache_key = f"funds:{filter.to_cache_key() if filter else 'all'}"

        # å°è¯•ä»ç¼“å­˜è·å–
        cached_funds = await self.cache.get(cache_key)
        if cached_funds:
            return cached_funds

        # ä»æ•°æ®åº“è·å–
        funds = await self.database.get_funds(filter)

        # ç¼“å­˜ç»“æœ
        await self.cache.set(cache_key, funds, ttl=3600)

        return funds

    async def update_fund_data(self, fund_code: str):
        """æ›´æ–°åŸºé‡‘æ•°æ®"""
        try:
            # è·å–æœ€æ–°æ•°æ®
            latest_data = await self.fetch_fund_data_from_api(fund_code)

            # æ›´æ–°æ•°æ®åº“
            await self.database.update_fund(fund_code, latest_data)

            # å‘é€æ›´æ–°äº‹ä»¶
            await self.message_queue.publish(
                exchange="fund_updates",
                routing_key=f"fund.updated.{fund_code}",
                message={
                    "fund_code": fund_code,
                    "timestamp": datetime.utcnow().isoformat(),
                    "data": latest_data,
                }
            )

            # æ¸…é™¤ç›¸å…³ç¼“å­˜
            await self.cache.delete_pattern(f"funds:*")

        except Exception as e:
            logger.error(f"Failed to update fund {fund_code}: {e}")
            raise

# äº‹ä»¶ç›‘å¬
@app.post("/webhooks/fund-updated")
async def handle_fund_updated_event(event: FundUpdatedEvent):
    """å¤„ç†åŸºé‡‘æ›´æ–°äº‹ä»¶"""
    service = FundDataService()

    # è§¦å‘ç›¸å…³æœåŠ¡æ›´æ–°
    await service.message_queue.publish(
        exchange="data_updates",
        routing_key="analysis.trigger",
        message={
            "fund_code": event.fund_code,
            "trigger_type": "fund_updated",
        }
    )

    return {"status": "processed"}
```

### 3.4 æ•°æ®æ¶æ„è®¾è®¡

#### 3.4.1 æ•°æ®åº“æ¶æ„

**åˆ†åº“åˆ†è¡¨ç­–ç•¥**ï¼š
```sql
-- åŸºé‡‘æ•°æ®åº“ (fund_db)
CREATE DATABASE fund_db;

-- ç”¨æˆ·æ•°æ®åº“ (user_db)
CREATE DATABASE user_db;

-- åˆ†ææ•°æ®åº“ (analysis_db)
CREATE DATABASE analysis_db;

-- åŸºé‡‘æ•°æ®è¡¨è®¾è®¡
CREATE TABLE fund_db.funds (
    code VARCHAR(10) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    company VARCHAR(50) NOT NULL,
    -- å…¶ä»–å­—æ®µ...
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (code);

-- æŒ‰åŸºé‡‘ä»£ç å“ˆå¸Œåˆ†ç‰‡
CREATE TABLE fund_db.funds_0 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE fund_db.funds_1 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE fund_db.funds_2 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE fund_db.funds_3 PARTITION OF fund_db.funds
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- åŸºé‡‘å‡€å€¼å†å²è¡¨ (æŒ‰æ—¶é—´åˆ†åŒº)
CREATE TABLE fund_db.fund_nav_history (
    id BIGSERIAL,
    fund_code VARCHAR(10) NOT NULL,
    nav_date DATE NOT NULL,
    nav_value NUMERIC(12, 4) NOT NULL,
    accumulated_nav NUMERIC(12, 4),
    daily_change NUMERIC(8, 4),
    daily_change_rate NUMERIC(8, 4),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id, nav_date)
) PARTITION BY RANGE (nav_date);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE fund_db.fund_nav_history_202401 PARTITION OF fund_db.fund_nav_history
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE fund_db.fund_nav_history_202402 PARTITION OF fund_db.fund_nav_history
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

**è¯»å†™åˆ†ç¦»æ¶æ„**ï¼š
```python
# database/db_manager.py - æ•°æ®åº“ç®¡ç†å™¨
import asyncpg
from typing import Union, Dict, Any
from contextlib import asynccontextmanager

class DatabaseManager:
    def __init__(self, config: DatabaseConfig):
        self.master_config = config.master
        self.slave_configs = config.slaves
        self.current_slave_index = 0

    async def get_master_connection(self):
        """è·å–ä¸»åº“è¿æ¥ï¼ˆå†™æ“ä½œï¼‰"""
        return await asyncpg.connect(
            **self.master_config.dict(),
            min_size=5,
            max_size=20,
        )

    async def get_slave_connection(self):
        """è·å–ä»åº“è¿æ¥ï¼ˆè¯»æ“ä½œï¼‰"""
        slave_config = self.get_next_slave_config()
        return await asyncpg.connect(
            **slave_config.dict(),
            min_size=5,
            max_size=20,
        )

    def get_next_slave_config(self):
        """è½®è¯¢è·å–ä»åº“é…ç½®"""
        config = self.slave_configs[self.current_slave_index]
        self.current_slave_index = (self.current_slave_index + 1) % len(self.slave_configs)
        return config

    @asynccontextmanager
    async def get_connection(self, read_only: bool = False):
        """è·å–æ•°æ®åº“è¿æ¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        if read_only:
            conn = await self.get_slave_connection()
        else:
            conn = await self.get_master_connection()

        try:
            yield conn
        except Exception:
            await conn.rollback()
            raise
        finally:
            await conn.close()

    async def execute_query(
        self,
        query: str,
        params: Dict[str, Any] = None,
        read_only: bool = False,
    ) -> Any:
        """æ‰§è¡ŒSQLæŸ¥è¯¢"""
        async with self.get_connection(read_only=read_only) as conn:
            if read_only:
                return await conn.fetch(query, *params.values() if params else [])
            else:
                return await conn.execute(query, *params.values() if params else [])
```

#### 3.4.2 ç¼“å­˜æ¶æ„

**å¤šçº§ç¼“å­˜ç­–ç•¥**ï¼š
```python
# cache/cache_manager.py - ç¼“å­˜ç®¡ç†å™¨
import redis
import asyncio
from typing import Any, Optional, Union
from dataclasses import dataclass

@dataclass
class CacheConfig:
    local_cache_size: int = 1000
    local_cache_ttl: int = 300  # 5åˆ†é’Ÿ
    redis_ttl: int = 3600       # 1å°æ—¶

class MultiLevelCache:
    def __init__(self, config: CacheConfig):
        self.config = config
        self.local_cache = {}  # ç®€åŒ–çš„å†…å­˜ç¼“å­˜
        self.redis_client = redis.Redis.from_url("redis://localhost:6379")
        self.cache_stats = {
            "local_hits": 0,
            "redis_hits": 0,
            "misses": 0,
        }

    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜æ•°æ®"""
        # ç¬¬ä¸€çº§ï¼šæœ¬åœ°ç¼“å­˜
        if key in self.local_cache:
            self.cache_stats["local_hits"] += 1
            return self.local_cache[key]

        # ç¬¬äºŒçº§ï¼šRedisç¼“å­˜
        redis_data = await self._get_from_redis(key)
        if redis_data:
            self.cache_stats["redis_hits"] += 1
            # å›å¡«æœ¬åœ°ç¼“å­˜
            self.local_cache[key] = redis_data
            return redis_data

        # ç¼“å­˜æœªå‘½ä¸­
        self.cache_stats["misses"] += 1
        return None

    async def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[int] = None,
    ) -> bool:
        """è®¾ç½®ç¼“å­˜æ•°æ®"""
        try:
            # è®¾ç½®æœ¬åœ°ç¼“å­˜
            self.local_cache[key] = value

            # è®¾ç½®Redisç¼“å­˜
            redis_ttl = ttl or self.config.redis_ttl
            await self._set_to_redis(key, value, redis_ttl)

            # æœ¬åœ°ç¼“å­˜è¿‡æœŸå¤„ç†
            asyncio.create_task(
                self._expire_local_cache(key, ttl or self.config.local_cache_ttl)
            )

            return True
        except Exception as e:
            logger.error(f"Cache set error: {e}")
            return False

    async def _get_from_redis(self, key: str) -> Optional[Any]:
        """ä»Redisè·å–æ•°æ®"""
        try:
            data = self.redis_client.get(key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logger.error(f"Redis get error: {e}")
            return None

    async def _set_to_redis(self, key: str, value: Any, ttl: int) -> bool:
        """è®¾ç½®Redisæ•°æ®"""
        try:
            return self.redis_client.setex(
                key, ttl, json.dumps(value, default=str)
            )
        except Exception as e:
            logger.error(f"Redis set error: {e}")
            return False

    async def _expire_local_cache(self, key: str, ttl: int):
        """æœ¬åœ°ç¼“å­˜è¿‡æœŸ"""
        await asyncio.sleep(ttl)
        if key in self.local_cache:
            del self.local_cache[key]

    def get_cache_stats(self) -> Dict[str, int]:
        """è·å–ç¼“å­˜ç»Ÿè®¡"""
        total_requests = (
            self.cache_stats["local_hits"] +
            self.cache_stats["redis_hits"] +
            self.cache_stats["misses"]
        )

        if total_requests == 0:
            return self.cache_stats

        return {
            **self.cache_stats,
            "hit_rate": (
                self.cache_stats["local_hits"] + self.cache_stats["redis_hits"]
            ) / total_requests,
            "local_hit_rate": self.cache_stats["local_hits"] / total_requests,
            "redis_hit_rate": self.cache_stats["redis_hits"] / total_requests,
        }
```

### 3.5 æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„

#### 3.5.1 äº‹ä»¶é©±åŠ¨æ¶æ„

**æ¶ˆæ¯é˜Ÿåˆ—è®¾è®¡**ï¼š
```python
# messaging/message_queue.py - æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†
import asyncio
from typing import Dict, Any, Callable
import aio_pika
from dataclasses import dataclass

@dataclass
class Message:
    exchange: str
    routing_key: str
    payload: Dict[str, Any]
    headers: Dict[str, Any] = None

class MessageQueue:
    def __init__(self, connection_url: str):
        self.connection_url = connection_url
        self.connection = None
        self.channel = None
        self.exchanges = {}
        self.consumers = {}

    async def connect(self):
        """è¿æ¥åˆ°æ¶ˆæ¯é˜Ÿåˆ—"""
        self.connection = await aio_pika.connect_robust(self.connection_url)
        self.channel = await self.connection.channel()

    async def setup_exchanges(self):
        """è®¾ç½®äº¤æ¢æœº"""
        exchanges_config = {
            "fund_updates": aio_pika.ExchangeType.TOPIC,
            "data_updates": aio_pika.ExchangeType.TOPIC,
            "user_events": aio_pika.ExchangeType.TOPIC,
            "notifications": aio_pika.ExchangeType.FANOUT,
        }

        for exchange_name, exchange_type in exchanges_config.items():
            exchange = await self.channel.declare_exchange(
                exchange_name, exchange_type, durable=True
            )
            self.exchanges[exchange_name] = exchange

    async def publish_message(self, message: Message) -> bool:
        """å‘å¸ƒæ¶ˆæ¯"""
        try:
            exchange = self.exchanges.get(message.exchange)
            if not exchange:
                raise ValueError(f"Exchange {message.exchange} not found")

            message_body = aio_pika.Message(
                json.dumps(message.payload).encode(),
                content_type="application/json",
                headers=message.headers or {},
                delivery_mode=2,  # æŒä¹…åŒ–æ¶ˆæ¯
            )

            await exchange.publish(
                message_body,
                routing_key=message.routing_key,
            )
            return True
        except Exception as e:
            logger.error(f"Failed to publish message: {e}")
            return False

    async def subscribe_to_queue(
        self,
        queue_name: str,
        exchange_name: str,
        routing_key: str,
        callback: Callable[[Dict[str, Any]], None],
    ) -> str:
        """è®¢é˜…é˜Ÿåˆ—"""
        try:
            exchange = self.exchanges.get(exchange_name)
            if not exchange:
                raise ValueError(f"Exchange {exchange_name} not found")

            # å£°æ˜é˜Ÿåˆ—
            queue = await self.channel.declare_queue(
                queue_name, durable=True
            )

            # ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢æœº
            await queue.bind(exchange, routing_key)

            # åˆ›å»ºæ¶ˆè´¹è€…
            async def message_handler(message: aio_pika.IncomingMessage):
                async with message.process():
                    try:
                        payload = json.loads(message.body.decode())
                        await callback(payload)
                    except Exception as e:
                        logger.error(f"Message handler error: {e}")

            consumer_tag = await queue.consume(message_handler)
            self.consumers[queue_name] = consumer_tag

            return consumer_tag
        except Exception as e:
            logger.error(f"Failed to subscribe to queue: {e}")
            raise

# äº‹ä»¶å¤„ç†ç¤ºä¾‹
class FundEventHandler:
    def __init__(self, message_queue: MessageQueue):
        self.message_queue = message_queue

    async def handle_fund_updated(self, event: Dict[str, Any]):
        """å¤„ç†åŸºé‡‘æ›´æ–°äº‹ä»¶"""
        fund_code = event.get("fund_code")

        # è§¦å‘ç›¸å…³åˆ†ææœåŠ¡
        await self.message_queue.publish_message(Message(
            exchange="data_updates",
            routing_key="analysis.trigger",
            payload={
                "fund_code": fund_code,
                "trigger_type": "fund_updated",
                "timestamp": datetime.utcnow().isoformat(),
            }
        ))

        # å‘é€é€šçŸ¥ç»™å…³æ³¨è¯¥åŸºé‡‘çš„ç”¨æˆ·
        await self.message_queue.publish_message(Message(
            exchange="notifications",
            routing_key="fund.updated",
            payload={
                "fund_code": fund_code,
                "message": f"åŸºé‡‘ {fund_code} æ•°æ®å·²æ›´æ–°",
                "timestamp": datetime.utcnow().isoformat(),
            }
        ))
```

### 3.6 ç›‘æ§å’Œå¯è§‚æµ‹æ€§

#### 3.6.1 åˆ†å¸ƒå¼è¿½è¸ª

**OpenTelemetryé›†æˆ**ï¼š
```python
# monitoring/tracing.py - åˆ†å¸ƒå¼è¿½è¸ª
from opentelemetry import trace, baggage, context
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
import functools

class TracingManager:
    def __init__(self):
        self.setup_tracing()

    def setup_tracing(self):
        """è®¾ç½®åˆ†å¸ƒå¼è¿½è¸ª"""
        trace.set_tracer_provider(TracerProvider())
        tracer = trace.get_tracer(__name__)

        jaeger_exporter = JaegerExporter(
            agent_host_name="localhost",
            agent_port=6831,
        )

        span_processor = BatchSpanProcessor(jaeger_exporter)
        trace.get_tracer_provider().add_span_processor(span_processor)

    def trace_function(self, operation_name: str):
        """å‡½æ•°è¿½è¸ªè£…é¥°å™¨"""
        def decorator(func):
            @functools.wraps(func)
            async def wrapper(*args, **kwargs):
                tracer = trace.get_tracer(__name__)

                with tracer.start_as_current_span(operation_name) as span:
                    span.set_attribute("function.name", func.__name__)
                    span.set_attribute("function.module", func.__module__)

                    try:
                        result = await func(*args, **kwargs)
                        span.set_status(trace.Status(trace.StatusCode.OK))
                        return result
                    except Exception as e:
                        span.set_status(
                            trace.Status(
                                trace.StatusCode.ERROR,
                                description=str(e)
                            )
                        )
                        span.record_exception(e)
                        raise
            return wrapper
        return decorator

# ä½¿ç”¨ç¤ºä¾‹
tracing_manager = TracingManager()

@tracing_manager.trace_function("get_fund_data")
async def get_fund_data(fund_code: str) -> Fund:
    # å®ç°è·å–åŸºé‡‘æ•°æ®çš„é€»è¾‘
    pass

# FastAPIé›†æˆ
app = FastAPI()
FastAPIInstrumentor.instrument_app(app)
SQLAlchemyInstrumentor().instrument(engine=engine)
```

---

*æœ¬ç« èŠ‚è¯¦ç»†è¯´æ˜äº†åŸºé€Ÿå¹³å°çš„ç³»ç»Ÿæ¶æ„è®¾è®¡ï¼ŒåŒ…æ‹¬å‰ç«¯æ¶æ„ã€åç«¯å¾®æœåŠ¡ã€æ•°æ®æ¶æ„ã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰å„ä¸ªå±‚é¢çš„è®¾è®¡æ–¹æ¡ˆ*