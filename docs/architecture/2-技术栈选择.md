# 2. 技术栈选择

## 🛠️ 技术栈概述

基速基金量化分析平台采用现代化的技术栈组合，重点考虑了跨平台兼容性、开发效率、性能表现和未来扩展性。本章节详细说明各层技术选型的决策过程和技术优势。

### 2.1 前端技术栈

#### 2.1.1 核心框架选择

##### Flutter 3.13+ (主要选择)

**选择理由**：
- **跨平台统一性**: 一套代码库支持Web、移动端、桌面端
- **性能表现**: 编译为原生代码，性能接近原生应用
- **开发效率**: 热重载功能显著提升开发效率
- **生态丰富**: 拥有丰富的插件库和活跃的社区支持
- **UI一致性**: 确保不同平台间的视觉和交互一致性

**版本选择策略**：
```yaml
flutter:
  # 生产环境使用稳定版本
  version: "3.13.x"
  # 渐进式升级策略
  upgrade_strategy: "stable_only"
  # 安全更新优先
  security_patches: "auto_apply"

dart:
  # 与Flutter版本兼容
  version: "3.0.x"
  # 空安全特性
  null_safety: "enabled"
```

**具体版本配置**：
```yaml
# pubspec.yaml 核心依赖
dependencies:
  flutter:
    sdk: flutter

  # 状态管理
  flutter_bloc: ^8.1.3
  bloc: ^8.1.2

  # 网络请求
  dio: ^5.3.2
  retrofit: ^4.0.3
  json_annotation: ^4.8.1

  # 本地存储
  hive: ^2.2.3
  path_provider: ^2.1.1
  shared_preferences: ^2.2.2

  # UI组件
  fl_chart: ^0.63.0
  google_fonts: ^6.1.0
  flutter_svg: ^2.0.9
  cached_network_image: ^3.3.0

  # 工具库
  get_it: ^7.6.4
  logger: ^2.0.2+1
  intl: ^0.18.1
```

##### 备选方案评估

**React Native (备选方案评估）**

**优势**：
- 更大的开发者社区
- 更丰富的第三方库
- Web开发经验可直接复用

**劣势**：
- 性能不如Flutter
- 平台特定代码较多
- UI一致性难以保证

**选择Flutter的核心原因**：
1. 性能要求高，Flutter更接近原生性能
2. 需要高度定制化的数据可视化组件
3. 统一的UI体验对产品非常重要

#### 2.1.2 状态管理架构

##### BLoC (Business Logic Component)

**架构选择理由**：
- **分离关注点**: 清晰分离业务逻辑和UI表现
- **可测试性**: 业务逻辑可以独立于UI进行测试
- **可维护性**: 代码结构清晰，便于维护和扩展
- **性能优化**: 支持状态缓存和高效的状态更新

**BLoC架构实现**：
```dart
// 基础BLoC实现示例
abstract class BaseBloc<Event, State> extends Bloc<Event, State> {
  BaseBloc(super.initialState);

  @override
  void onError(BlocBase bloc, Object error, StackTrace stackTrace) {
    super.onError(bloc, error, stackTrace);
    Logger().error('BLoC Error', error: error, stackTrace: stackTrace);
  }

  @override
  void onTransition(Bloc bloc, Transition<Event, State> transition) {
    super.onTransition(bloc, transition);
    Logger().info('State Transition: ${transition.currentState} -> ${transition.nextState}');
  }
}

// 基金搜索BLoC示例
class FundSearchBloc extends BaseBloc<FundSearchEvent, FundSearchState> {
  final FundRepository _fundRepository;

  FundSearchBloc(this._fundRepository) : super(FundSearchInitial()) {
    on<SearchFunds>(_onSearchFunds);
    on<LoadSearchHistory>(_onLoadSearchHistory);
    on<ClearSearchHistory>(_onClearSearchHistory);
  }

  Future<void> _onSearchFunds(
    SearchFunds event,
    Emitter<FundSearchState> emit,
  ) async {
    if (event.query.isEmpty) {
      emit(FundSearchInitial());
      return;
    }

    emit(FundSearchLoading());

    try {
      final funds = await _fundRepository.searchFunds(event.query);
      emit(FundSearchLoaded(funds));
    } catch (error) {
      emit(FundSearchError(error.toString()));
    }
  }
}
```

#### 2.1.3 UI组件库

##### Material Design 3 + 定制化组件

**设计系统架构**：
```dart
// 主题配置
class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF1E88E5),
        brightness: Brightness.light,
      ),
      textTheme: TextTheme(
        displayLarge: GoogleFonts.inter(
          fontSize: 32,
          fontWeight: FontWeight.bold,
        ),
        headlineMedium: GoogleFonts.inter(
          fontSize: 24,
          fontWeight: FontWeight.w600,
        ),
        bodyLarge: GoogleFonts.inter(
          fontSize: 16,
          fontWeight: FontWeight.normal,
        ),
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: const Color(0xFF1E88E5),
        brightness: Brightness.dark,
      ),
    );
  }
}
```

**自定义组件架构**：
```dart
// 基金卡片组件
class FundCard extends StatelessWidget {
  final Fund fund;
  final VoidCallback? onTap;
  final VoidCallback? onFavorite;

  const FundCard({
    super.key,
    required this.fund,
    this.onTap,
    this.onFavorite,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          fund.name,
                          style: Theme.of(context).textTheme.headlineSmall,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 4),
                        Text(
                          fund.code,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    onPressed: onFavorite,
                    icon: Icon(
                      fund.isFavorite ? Icons.favorite : Icons.favorite_border,
                      color: fund.isFavorite ? Colors.red : null,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  _buildInfoCard(
                    context,
                    '最新净值',
                    fund.latestNav.toStringAsFixed(4),
                  ),
                  _buildInfoCard(
                    context,
                    '日涨幅',
                    '${fund.dailyChange.toStringAsFixed(2)}%',
                    valueColor: fund.dailyChange >= 0 ? Colors.green : Colors.red,
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildInfoCard(
    BuildContext context,
    String label,
    String value, {
    Color? valueColor,
  }) {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            label,
            style: Theme.of(context).textTheme.bodySmall,
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
          const SizedBox(height: 2),
          Text(
            value,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
              color: valueColor,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }
}
```

### 2.2 后端技术栈

#### 2.2.1 API服务架构

##### Python FastAPI (推荐方案)

**技术选型理由**：
- **性能优秀**: 异步支持，性能远超传统框架
- **开发效率**: 自动API文档生成，类型提示支持
- **生态丰富**: 强大的数据科学生态支持
- **部署简单**: 内置ASGI支持，部署配置简单

**FastAPI核心配置**：
```python
# main.py - FastAPI应用入口
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from contextlib import asynccontextmanager
import uvicorn

from app.core.config import settings
from app.api.v1.api import api_router
from app.core.database import engine, Base


@asynccontextmanager
async def lifespan(app: FastAPI):
    # 应用启动时执行
    Base.metadata.create_all(bind=engine)
    print("Database tables created")

    yield

    # 应用关闭时执行
    print("Application shutting down")


# FastAPI应用实例
app = FastAPI(
    title="基速基金数据API",
    description="专业的基金数据服务API",
    version="1.0.0",
    lifespan=lifespan,
    docs_url="/api/docs",
    redoc_url="/api/redoc",
)

# 中间件配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=settings.ALLOWED_HOSTS,
)

# 路由注册
app.include_router(api_router, prefix="/api/v1")


if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        workers=1 if settings.DEBUG else 4,
    )
```

**配置管理**：
```python
# core/config.py - 配置管理
from pydantic_settings import BaseSettings
from typing import List
import os


class Settings(BaseSettings):
    # 基础配置
    PROJECT_NAME: str = "基速基金数据API"
    VERSION: str = "1.0.0"
    DEBUG: bool = False

    # 服务器配置
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # 安全配置
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-here")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # 数据库配置
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql://user:password@localhost/dbname")

    # Redis配置
    REDIS_URL: str = os.getenv("REDIS_URL", "redis://localhost:6379")

    # CORS配置
    ALLOWED_ORIGINS: List[str] = [
        "http://localhost:3000",
        "http://localhost:8080",
        "https://yourdomain.com",
    ]

    # API密钥配置
    AKSHARE_API_KEY: str = os.getenv("AKSHARE_API_KEY", "")

    class Config:
        env_file = ".env"
        case_sensitive = True


settings = Settings()
```

##### 备选方案：Node.js Express

**评估结果**：
- **优势**: JavaScript生态，前端开发经验可复用
- **劣势**: 异步处理复杂度较高，性能不如FastAPI
- **选择原因**: Python在数据处理和金融分析方面更有优势

#### 2.2.2 数据库技术栈

##### PostgreSQL 15+ (主数据库)

**选择理由**：
- **数据完整性**: 强大的事务支持和数据一致性保证
- **性能表现**: 优秀的查询性能和并发处理能力
- **扩展性**: 支持水平扩展和读写分离
- **功能丰富**: 支持JSON字段、全文搜索等高级功能

**数据库架构设计**：
```sql
-- 基金基本信息表
CREATE TABLE funds (
    code VARCHAR(10) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    company VARCHAR(50) NOT NULL,
    establishment_date DATE,
    latest_nav NUMERIC(12, 4),
    latest_date DATE,
    total_assets NUMERIC(18, 2),
    management_fee NUMERIC(5, 3),
    custodian_fee NUMERIC(5, 3),
    performance_fee NUMERIC(5, 3),
    risk_level VARCHAR(10),
    investment_target TEXT,
    investment_strategy TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 基金净值历史表
CREATE TABLE fund_nav_history (
    id SERIAL PRIMARY KEY,
    fund_code VARCHAR(10) REFERENCES funds(code),
    nav_date DATE NOT NULL,
    nav_value NUMERIC(12, 4) NOT NULL,
    accumulated_nav NUMERIC(12, 4),
    daily_change NUMERIC(8, 4),
    daily_change_rate NUMERIC(8, 4),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_fund_date UNIQUE (fund_code, nav_date)
);

-- 基金分红历史表
CREATE TABLE fund_dividends (
    id SERIAL PRIMARY KEY,
    fund_code VARCHAR(10) REFERENCES funds(code),
    ex_dividend_date DATE NOT NULL,
    dividend_value NUMERIC(12, 4),
    dividend_type VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 用户收藏基金表
CREATE TABLE user_favorites (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(100) NOT NULL,
    fund_code VARCHAR(10) REFERENCES funds(code),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_user_fund UNIQUE (user_id, fund_code)
);

-- 索引优化
CREATE INDEX idx_funds_type ON funds(type);
CREATE INDEX idx_funds_company ON funds(company);
CREATE INDEX idx_fund_nav_history_date ON fund_nav_history(nav_date);
CREATE INDEX idx_fund_nav_history_fund_code ON fund_nav_history(fund_code);
CREATE INDEX idx_user_favorites_user_id ON user_favorites(user_id);

-- 分区策略 (大数据量时使用)
-- CREATE TABLE fund_nav_history_2024 PARTITION OF fund_nav_history
--     FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

**数据库连接配置**：
```python
# core/database.py - 数据库配置
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager
import logging

from .config import settings

# 数据库引擎配置
engine = create_engine(
    settings.DATABASE_URL,
    pool_size=20,
    max_overflow=30,
    pool_pre_ping=True,
    pool_recycle=3600,
    echo=settings.DEBUG,
)

# 会话工厂
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
)

# 基类
Base = declarative_base()


# 数据库会话管理
def get_db():
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logging.error(f"Database session error: {e}")
        db.rollback()
        raise
    finally:
        db.close()


@contextmanager
def get_db_session():
    """上下文管理器形式的数据库会话"""
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()
```

#### 2.2.3 缓存技术栈

##### Redis 7+ (缓存层)

**选择理由**：
- **性能优秀**: 内存数据库，访问速度极快
- **数据结构丰富**: 支持多种数据类型
- **持久化支持**: 支持数据持久化，避免数据丢失
- **生态完善**: 与Python/Node.js等语言集成良好

**缓存架构设计**：
```python
# core/cache.py - Redis缓存配置
import redis
import json
import logging
from typing import Optional, Any
from datetime import timedelta
from .config import settings

class RedisCache:
    def __init__(self):
        self.redis_client = redis.Redis.from_url(settings.REDIS_URL, decode_responses=True)
        self.default_ttl = 3600  # 1小时默认过期时间

    async def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        try:
            data = self.redis_client.get(key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logging.error(f"Redis GET error: {e}")
            return None

    async def set(
        self,
        key: str,
        value: Any,
        ttl: Optional[int] = None
    ) -> bool:
        """设置缓存数据"""
        try:
            ttl = ttl or self.default_ttl
            return self.redis_client.setex(key, ttl, json.dumps(value, default=str))
        except Exception as e:
            logging.error(f"Redis SET error: {e}")
            return False

    async def delete(self, key: str) -> bool:
        """删除缓存数据"""
        try:
            return bool(self.redis_client.delete(key))
        except Exception as e:
            logging.error(f"Redis DELETE error: {e}")
            return False

    async def clear_pattern(self, pattern: str) -> int:
        """清除匹配模式的所有缓存"""
        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logging.error(f"Redis CLEAR_PATTERN error: {e}")
            return 0


# 全局缓存实例
cache = RedisCache()

# 缓存装饰器
def cache_result(ttl: int = 3600, key_prefix: str = ""):
    """缓存函数结果的装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # 生成缓存key
            cache_key = f"{key_prefix}{func.__name__}:{str(args)}:{str(kwargs)}"

            # 尝试从缓存获取
            cached_result = await cache.get(cache_key)
            if cached_result is not None:
                return cached_result

            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            await cache.set(cache_key, result, ttl)
            return result
        return wrapper
    return decorator
```

### 2.3 开发和运维工具

#### 2.3.1 代码生成和构建工具

##### 自动化代码生成

**build_runner配置**：
```yaml
# pubspec.yaml 开发依赖
dev_dependencies:
  build_runner: ^2.4.6
  json_serializable: ^6.7.1
  retrofit_generator: ^7.0.8
  hive_generator: ^2.0.1
  flutter_lints: ^3.0.1
  flutter_test:
    sdk: flutter

# 构建脚本
scripts:
  build: "flutter pub run build_runner build --delete-conflicting-outputs"
  build-watch: "flutter pub run build_runner watch --delete-conflicting-outputs"
  clean-build: "flutter pub run build_runner clean"
```

**数据模型生成**：
```dart
// fund_model.dart - 数据模型定义
import 'package:json_annotation/json_annotation.dart';

part 'fund_model.g.dart';

@JsonSerializable()
class Fund {
  final String code;
  final String name;
  final String type;
  final String company;
  final DateTime? establishmentDate;
  final double? latestNav;
  final DateTime? latestDate;
  final double? totalAssets;
  final double? managementFee;
  final double? custodianFee;
  final double? performanceFee;
  final String? riskLevel;
  final String? investmentTarget;
  final String? investmentStrategy;
  final bool isFavorite;
  final DateTime? lastUpdated;

  Fund({
    required this.code,
    required this.name,
    required this.type,
    required this.company,
    this.establishmentDate,
    this.latestNav,
    this.latestDate,
    this.totalAssets,
    this.managementFee,
    this.custodianFee,
    this.performanceFee,
    this.riskLevel,
    this.investmentTarget,
    this.investmentStrategy,
    this.isFavorite = false,
    this.lastUpdated,
  });

  factory Fund.fromJson(Map<String, dynamic> json) => _$FundFromJson(json);
  Map<String, dynamic> toJson() => _$FundToJson(this);

  Fund copyWith({
    String? code,
    String? name,
    String? type,
    String? company,
    DateTime? establishmentDate,
    double? latestNav,
    DateTime? latestDate,
    double? totalAssets,
    double? managementFee,
    double? custodianFee,
    double? performanceFee,
    String? riskLevel,
    String? investmentTarget,
    String? investmentStrategy,
    bool? isFavorite,
    DateTime? lastUpdated,
  }) {
    return Fund(
      code: code ?? this.code,
      name: name ?? this.name,
      type: type ?? this.type,
      company: company ?? this.company,
      establishmentDate: establishmentDate ?? this.establishmentDate,
      latestNav: latestNav ?? this.latestNav,
      latestDate: latestDate ?? this.latestDate,
      totalAssets: totalAssets ?? this.totalAssets,
      managementFee: managementFee ?? this.managementFee,
      custodianFee: custodianFee ?? this.custodianFee,
      performanceFee: performanceFee ?? this.performanceFee,
      riskLevel: riskLevel ?? this.riskLevel,
      investmentTarget: investmentTarget ?? this.investmentTarget,
      investmentStrategy: investmentStrategy ?? this.investmentStrategy,
      isFavorite: isFavorite ?? this.isFavorite,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }
}
```

#### 2.3.2 CI/CD工具链

##### GitHub Actions工作流

**Flutter构建配置**：
```yaml
# .github/workflows/flutter-build.yml
name: Flutter Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.13.x'
        channel: 'stable'
        cache: true
        cache-key: flutter-${{ runner.os }}-3.13.x-stable

    - name: Install dependencies
      run: flutter pub get

    - name: Generate code
      run: flutter pub run build_runner build --delete-conflicting-outputs

    - name: Run Flutter tests
      run: flutter test --coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: coverage/lcov.info
        flags: flutter
        name: flutter-coverage

  build-android:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Java
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.13.x'
        channel: 'stable'
        cache: true

    - name: Install dependencies
      run: flutter pub get

    - name: Build Android APK
      run: flutter build apk --release

    - name: Upload APK artifact
      uses: actions/upload-artifact@v3
      with:
        name: android-release
        path: build/app/outputs/flutter-apk/app-release.apk

  build-web:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.13.x'
        channel: 'stable'
        cache: true

    - name: Install dependencies
      run: flutter pub get

    - name: Build web release
      run: flutter build web --release

    - name: Upload web artifact
      uses: actions/upload-artifact@v3
      with:
        name: web-release
        path: build/web
```

**Python API构建配置**：
```yaml
# .github/workflows/python-api.yml
name: Python API Build and Test

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'api/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'api/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install dependencies
      working-directory: ./api
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt

    - name: Run code linting
      working-directory: ./api
      run: |
        flake8 app/ tests/
        black --check app/ tests/

    - name: Run security checks
      working-directory: ./api
      run: |
        bandit -r app/

    - name: Run tests
      working-directory: ./api
      run: |
        pytest tests/ -v --cov=app --cov-report=xml --cov-report=html

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./api/coverage.xml
        flags: python-api
        name: python-coverage

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./api
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/jisu-api:latest
          ${{ secrets.DOCKER_USERNAME }}/jisu-api:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
```

### 2.4 监控和日志

#### 2.4.1 应用性能监控

**Sentry集成配置**：
```dart
// main.dart - Sentry集成
import 'package:sentry_flutter/sentry_flutter.dart';

Future<void> main() async {
  // Sentry配置
  await SentryFlutter.init(
    (options) {
      options.dsn = 'https://your-dsn@sentry.io/project-id';
      options.tracesSampleRate = 1.0;
      options.debug = kDebugMode;

      // 环境配置
      if (kDebugMode) {
        options.environment = 'development';
      } else if (kProfileMode) {
        options.environment = 'staging';
      } else {
        options.environment = 'production';
      }

      // 性能监控
      options.enableAutoPerformanceTracing = true;
      options.enableOutOfMemoryTracking = true;

      // 用户信息
      options beforeSend = (event) {
        if (event.request?.url?.contains('localhost') ?? false) {
          return null; // 忽略开发环境的错误
        }
        return event;
      };
    },
    appRunner: () => runApp(const JisuApp()),
  );
}
```

**性能监控实现**：
```dart
// performance_monitor.dart - 性能监控
import 'package:flutter/material.dart';
import 'package:sentry/sentry.dart';

class PerformanceMonitor {
  static final PerformanceMonitor _instance = PerformanceMonitor._internal();
  factory PerformanceMonitor() => _instance;
  PerformanceMonitor._internal();

  // 页面性能监控
  void startScreenTransition(String fromScreen, String toScreen) {
    Sentry.startTransaction(
      'screen_transition_$toScreen',
      'ui.interaction',
      description: 'Screen transition from $fromScreen to $toScreen',
      data: {
        'from_screen': fromScreen,
        'to_screen': toScreen,
      },
    );
  }

  // API请求性能监控
  Future<T> traceApiCall<T>(
    String apiName,
    Future<T> apiCall, {
    Map<String, dynamic>? data,
  }) async {
    final transaction = Sentry.startTransaction(
      'api_call_$apiName',
      'http.client',
      data: data,
    );

    try {
      final result = await apiCall;
      transaction.setData('status', 'success');
      return result;
    } catch (error, stackTrace) {
      transaction.setData('status', 'error');
      transaction.throwable = error;
      rethrow;
    } finally {
      await transaction.finish();
    }
  }

  // 数据库操作监控
  Future<T> traceDatabaseOperation<T>(
    String operation,
    Future<T> dbOperation, {
    Map<String, dynamic>? data,
  }) async {
    final transaction = Sentry.startTransaction(
      'db_operation_$operation',
      'db.query',
      data: data,
    );

    try {
      final result = await dbOperation;
      transaction.setData('status', 'success');
      return result;
    } catch (error, stackTrace) {
      transaction.setData('status', 'error');
      transaction.throwable = error;
      rethrow;
    } finally {
      await transaction.finish();
    }
  }
}
```

#### 2.4.2 日志系统

**应用日志配置**：
```dart
// app_logger.dart - 日志配置
import 'package:logger/logger.dart';

class AppLogger {
  static final Logger _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 0,
      errorMethodCount: 8,
      lineLength: 120,
      colors: true,
      printEmojis: true,
      printTime: true,
    ),
    level: kDebugMode ? Level.debug : Level.info,
    filter: ProductionFilter(),
  );

  static void debug(String message, {Object? error, StackTrace? stackTrace}) {
    _logger.d(message, error: error, stackTrace: stackTrace);
  }

  static void info(String message, {Object? error, StackTrace? stackTrace}) {
    _logger.i(message, error: error, stackTrace: stackTrace);
  }

  static void warning(String message, {Object? error, StackTrace? stackTrace}) {
    _logger.w(message, error: error, stackTrace: stackTrace);
  }

  static void error(String message, {Object? error, StackTrace? stackTrace}) {
    _logger.e(message, error: error, stackTrace: stackTrace);
  }

  static void logApiCall(String method, String url, {int? statusCode, int? duration}) {
    _logger.i(
      'API Call: $method $url',
      error: statusCode != null && statusCode >= 400 ? 'HTTP $statusCode' : null,
      time: Duration(milliseconds: duration ?? 0),
    );
  }
}

class ProductionFilter extends LogFilter {
  @override
  bool shouldLog(LogEvent event) {
    if (!kDebugMode && event.level == Level.debug) {
      return false;
    }
    return true;
  }
}
```

---

## 🎯 技术选型总结

### 2.5 技术栈优势分析

#### 跨平台优势
- **统一代码库**: Flutter实现一次编码，多平台运行
- **开发效率**: 减少多平台适配工作量
- **维护成本**: 统一的代码库降低维护复杂度
- **体验一致性**: 确保不同平台的用户体验一致

#### 性能优势
- **Flutter性能**: 接近原生应用的性能表现
- **异步架构**: 全异步处理确保界面流畅
- **缓存优化**: 多级缓存策略提升响应速度
- **数据库优化**: PostgreSQL的高性能查询能力

#### 开发效率优势
- **热重载**: Flutter热重载显著提升开发效率
- **自动化工具**: 完善的自动化构建和测试工具
- **API文档**: FastAPI自动生成API文档
- **类型安全**: 强类型系统减少运行时错误

#### 扩展性优势
- **模块化架构**: 便于功能扩展和模块替换
- **云原生**: 支持容器化部署和云原生架构
- **微服务友好**: 可以轻松扩展为微服务架构
- **数据扩展**: 支持大规模数据处理和分析

### 2.6 技术风险控制

#### 主要技术风险
1. **Flutter版本兼容性**: 大版本升级可能带来兼容性问题
2. **第三方库依赖**: 过度依赖第三方库可能带来维护风险
3. **性能瓶颈**: 大数据处理可能存在性能瓶颈

#### 风险缓解策略
1. **版本锁定**: 在生产环境中使用经过验证的稳定版本
2. **依赖审查**: 定期审查第三方库的质量和维护状态
3. **性能测试**: 建立完善的性能测试和监控体系
4. **备份方案**: 为关键组件准备备选技术方案

---

*本章节详细说明了基速平台的技术栈选择，包括前端框架、后端服务、数据库、缓存等各个层面选型决策和技术优势*