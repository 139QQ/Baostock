import 'package:flutter_test/flutter_test.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';

import 'package:jisu_fund_analyzer/src/features/fund/domain/entities/fund_search_criteria.dart';
import 'package:jisu_fund_analyzer/src/features/fund/domain/entities/fund.dart';
import 'package:jisu_fund_analyzer/src/features/fund/domain/usecases/fund_search_usecase.dart';
import 'package:jisu_fund_analyzer/src/features/fund/presentation/bloc/search_bloc.dart';
import 'package:jisu_fund_analyzer/src/features/fund/presentation/bloc/search_event.dart';
import 'package:jisu_fund_analyzer/src/features/fund/presentation/bloc/search_state.dart';

import 'search_bloc_test.mocks.dart';

@GenerateMocks([FundSearchUseCase])
void main() {
  group('SearchBloc', () {
    late MockFundSearchUseCase mockSearchUseCase;
    late List<Fund> mockFunds;

    setUp(() {
      mockSearchUseCase = MockFundSearchUseCase();
      mockFunds = [
        Fund(
          code: '000001',
          name: '华夏成长混合',
          type: '混合型',
          company: '华夏基金',
          manager: '张三',
          unitNav: 1.2345,
          accumulatedNav: 2.3456,
          dailyReturn: 0.0123,
          return1W: 0.0234,
          return1M: 0.0345,
          return3M: 0.0456,
          return6M: 0.0567,
          return1Y: 0.0678,
          return2Y: 0.0789,
          return3Y: 0.0890,
          returnYTD: 0.0123,
          returnSinceInception: 1.2345,
          scale: 123.45,
          riskLevel: '中风险',
          status: 'active',
          date: '2023-01-01',
          fee: 0.015,
          rankingPosition: 1,
          totalCount: 100,
          currentPrice: 1.2345,
          dailyChange: 0.0123,
          dailyChangePercent: 1.23,
          lastUpdate: DateTime.now(),
        ),
        Fund(
          code: '000002',
          name: '易方达稳健收益',
          type: '债券型',
          company: '易方达基金',
          manager: '李四',
          unitNav: 1.1234,
          accumulatedNav: 1.5678,
          dailyReturn: 0.0056,
          return1W: 0.0112,
          return1M: 0.0223,
          return3M: 0.0334,
          return6M: 0.0445,
          return1Y: 0.0556,
          return2Y: 0.0667,
          return3Y: 0.0778,
          returnYTD: 0.0089,
          returnSinceInception: 0.5678,
          scale: 234.56,
          riskLevel: '低风险',
          status: 'active',
          date: '2023-01-01',
          fee: 0.008,
          rankingPosition: 2,
          totalCount: 100,
          currentPrice: 1.1234,
          dailyChange: 0.0056,
          dailyChangePercent: 0.56,
          lastUpdate: DateTime.now(),
        ),
      ];
    });

    group('构造函数', () {
      test('初始状态应该是SearchInitial', () {
        // Arrange & Act
        final searchBloc = SearchBloc(searchUseCase: mockSearchUseCase);

        // Assert
        expect(searchBloc.state, isA<SearchInitial>());
        searchBloc.close();
      });
    });

    group('InitializeSearch', () {
      blocTest<SearchBloc, SearchState>(
        '应该正确初始化搜索功能',
        build: () {
          when(mockSearchUseCase.getSearchHistory(limit: 10))
              .thenAnswer((_) async => ['华夏基金', '易方达']);
          when(mockSearchUseCase.getPopularSearches(limit: 10))
              .thenAnswer((_) async => ['股票基金', '债券基金', '混合基金']);
          when(mockSearchUseCase.getSearchStatistics())
              .thenAnswer((_) async => {'totalSearches': 100, 'averageSearchTime': 150});

          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const InitializeSearch()),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.searchHistory, 'searchHistory', ['华夏基金', '易方达'])
              .having((state) => state.popularSearches, 'popularSearches', ['股票基金', '债券基金', '混合基金'])
              .having((state) => state.statistics, 'statistics', {'totalSearches': 100, 'averageSearchTime': 150})
              .having((state) => state.suggestions, 'suggestions', []),
              .having((state) => state.searchResult, 'searchResult', null),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.getSearchHistory(limit: 10)).called(1);
          verify(mockSearchUseCase.getPopularSearches(limit: 10)).called(1);
          verify(mockSearchUseCase.getSearchStatistics()).called(1);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '初始化失败时应该返回SearchLoadFailure',
        build: () {
          when(mockSearchUseCase.getSearchHistory(limit: 10))
              .thenThrow(Exception('获取搜索历史失败'));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const InitializeSearch()),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadFailure>()
              .having((state) => state.errorMessage, 'errorMessage', 'Exception: 获取搜索历史失败'),
        ],
      );
    });

    group('PerformSearch', () {
      blocTest<SearchBloc, SearchState>(
        '应该成功执行搜索',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: mockFunds.length,
                    searchTimeMs: 120,
                    criteria: const FundSearchCriteria.keyword('华夏'),
                    hasMore: false,
                    suggestions: ['华夏基金', '成长基金'],
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const PerformSearch(criteria: FundSearchCriteria.keyword('华夏'))),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.searchResult, 'searchResult', isNotNull)
              .having((state) => state.searchResult!.funds.length, 'funds length', 2)
              .having((state) => state.searchResult!.totalCount, 'totalCount', 2)
              .having((state) => state.searchResult!.searchTimeMs, 'searchTimeMs', 120)
              .having((state) => state.suggestions, 'suggestions', ['华夏基金', '成长基金']),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.execute(any)).called(1);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '搜索失败时应该返回SearchLoadFailure',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenThrow(Exception('搜索失败'));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const PerformSearch(criteria: FundSearchCriteria.keyword('test'))),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadFailure>()
              .having((state) => state.errorMessage, 'errorMessage', 'Exception: 搜索失败'),
        ],
      );

      blocTest<SearchBloc, SearchState>(
        '空搜索结果应该返回空状态',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult.empty(
                    criteria: const FundSearchCriteria.keyword('nonexistent'),
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const PerformSearch(criteria: const FundSearchCriteria.keyword('nonexistent'))),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.searchResult, 'searchResult', isNotNull)
              .having((state) => state.searchResult!.isEmpty, 'isEmpty', true),
        ],
      );
    });

    group('UpdateSearchKeyword', () {
      blocTest<SearchBloc, SearchState>(
        '应该更新搜索关键词并获取建议',
        build: () {
          when(mockSearchUseCase.getSearchSuggestions('华夏', limit: 8))
              .thenAnswer((_) async => ['华夏基金', '华夏成长', '华夏回报']);
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const UpdateSearchKeyword(keyword: '华夏')),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.currentKeyword, 'currentKeyword', '华夏')
              .having((state) => state.suggestions, 'suggestions', ['华夏基金', '华夏成长', '华夏回报']),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.getSearchSuggestions('华夏', limit: 8)).called(1);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '空关键词应该清空建议',
        build: () {
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const UpdateSearchKeyword(keyword: '')),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.currentKeyword, 'currentKeyword', '')
              .having((state) => state.suggestions, 'suggestions', []),
        ],
      );

      blocTest<SearchBloc, SearchState>(
        '获取建议失败应该保持状态',
        build: () {
          when(mockSearchUseCase.getSearchSuggestions('test', limit: 8))
              .thenThrow(Exception('获取建议失败'));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const UpdateSearchKeyword(keyword: 'test')),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.currentKeyword, 'currentKeyword', 'test')
              .having((state) => state.suggestions, 'suggestions', []),
        ],
      );
    });

    group('ClearSearch', () {
      blocTest<SearchBloc, SearchState>(
        '应该清空搜索结果',
        build: () {
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const ClearSearch()),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.currentKeyword, 'currentKeyword', '')
              .having((state) => state.searchResult, 'searchResult', null)
              .having((state) => state.suggestions, 'suggestions', []),
        ],
      );
    });

    group('RefreshSearch', () {
      blocTest<SearchBloc, SearchState>(
        '应该刷新当前搜索',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: mockFunds.length,
                    searchTimeMs: 100,
                    criteria: const FundSearchCriteria.keyword('华夏'),
                    hasMore: false,
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) {
          // 先设置一个搜索结果
          bloc.add(const PerformSearch(criteria: FundSearchCriteria.keyword('华夏')));
          // 然后刷新
          return bloc.add(const RefreshSearch());
        },
        expect: () => [
          // 第一个搜索
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>(),
          // 刷新搜索
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.searchResult, 'searchResult', isNotNull),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.execute(any)).called(2);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '没有当前搜索条件时刷新应该返回空状态',
        build: () {
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const RefreshSearch()),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.searchResult, 'searchResult', null),
        ],
      );
    });

    group('SelectSearchSuggestion', () {
      blocTest<SearchBloc, SearchState>(
        '应该选择搜索建议并执行搜索',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: mockFunds.length,
                    searchTimeMs: 80,
                    criteria: const FundSearchCriteria.keyword('华夏基金'),
                    hasMore: false,
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const SelectSearchSuggestion(suggestion: '华夏基金')),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.currentKeyword, 'currentKeyword', '华夏基金')
              .having((state) => state.searchResult, 'searchResult', isNotNull)
              .having((state) => state.suggestions, 'suggestions', []),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.execute(any)).called(1);
        },
      );
    });

    group('SaveSearchHistory', () {
      blocTest<SearchBloc, SearchState>(
        '应该保存搜索历史',
        build: () {
          when(mockSearchUseCase.saveSearchHistory('华夏基金'))
              .thenAnswer((_) async => true);
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const SaveSearchHistory(keyword: '华夏基金')),
        expect: () => [
          isA<SearchLoadSuccess>(),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.saveSearchHistory('华夏基金')).called(1);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '保存搜索历史失败应该保持状态',
        build: () {
          when(mockSearchUseCase.saveSearchHistory('test'))
              .thenThrow(Exception('保存失败'));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const SaveSearchHistory(keyword: 'test')),
        expect: () => [
          isA<SearchLoadSuccess>(),
        ],
      );
    });

    group('DeleteSearchHistory', () {
      blocTest<SearchBloc, SearchState>(
        '应该删除搜索历史',
        build: () {
          when(mockSearchUseCase.deleteSearchHistory('华夏基金'))
              .thenAnswer((_) async => true);
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const DeleteSearchHistory(keyword: '华夏基金')),
        expect: () => [
          isA<SearchLoadSuccess>(),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.deleteSearchHistory('华夏基金')).called(1);
        },
      );
    });

    group('ClearSearchHistory', () {
      blocTest<SearchBloc, SearchState>(
        '应该清空搜索历史',
        build: () {
          when(mockSearchUseCase.clearSearchHistory())
              .thenAnswer((_) async => true);
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const ClearSearchHistory()),
        expect: () => [
          isA<SearchLoadSuccess>()
              .having((state) => state.searchHistory, 'searchHistory', []),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.clearSearchHistory()).called(1);
        },
      );
    });

    group('LoadMoreResults', () {
      blocTest<SearchBloc, SearchState>(
        '应该加载更多搜索结果',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: 25,
                    searchTimeMs: 100,
                    criteria: const FundSearchCriteria.keyword('华夏', limit: 20),
                    hasMore: true,
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) {
          // 先执行初始搜索
          bloc.add(const PerformSearch(criteria: const FundSearchCriteria.keyword('华夏', limit: 20)));
          // 然后加载更多
          return bloc.add(const LoadMoreResults());
        },
        expect: () => [
          // 初始搜索
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>(),
          // 加载更多
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>()
              .having((state) => state.searchResult, 'searchResult', isNotNull)
              .having((state) => state.searchResult!.hasMore, 'hasMore', true),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.execute(any)).called(2);
        },
      );

      blocTest<SearchBloc, SearchState>(
        '没有更多结果时不应该加载',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: mockFunds.length,
                    searchTimeMs: 100,
                    criteria: const FundSearchCriteria.keyword('test'),
                    hasMore: false,
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) {
          // 先执行搜索
          bloc.add(const PerformSearch(criteria: const FundSearchCriteria.keyword('test')));
          // 尝试加载更多
          return bloc.add(const LoadMoreResults());
        },
        expect: () => [
          // 只执行初始搜索，不应该加载更多
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>(),
        ],
        verify: (bloc) {
          verify(mockSearchUseCase.execute(any)).called(1);
        },
      );
    });

    group('性能测试', () {
      blocTest<SearchBloc, SearchState>(
        '应该在300ms内完成搜索',
        build: () {
          when(mockSearchUseCase.execute(any))
              .thenAnswer((_) async => SearchResult(
                    funds: mockFunds,
                    totalCount: mockFunds.length,
                    searchTimeMs: 250, // 250ms < 300ms
                    criteria: const FundSearchCriteria.keyword('test'),
                    hasMore: false,
                  ));
          return SearchBloc(searchUseCase: mockSearchUseCase);
        },
        act: (bloc) => bloc.add(const PerformSearch(criteria: const FundSearchCriteria.keyword('test'))),
        expect: () => [
          isA<SearchLoadInProgress>(),
          isA<SearchLoadSuccess>(),
        ],
        wait: const Duration(milliseconds: 300), // 确保在300ms内完成
      );
    });
  });
}